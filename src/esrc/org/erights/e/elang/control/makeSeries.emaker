#!/usr/bin/env rune

# Copyright 2004 Mark S. Miller, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")
pragma.enable("explicit-result-guard")

def EIteratable := <type:org.erights.e.elib.tables.EIteratable>

    ? pragma.syntax("0.9")
    ? pragma.enable("lambda-args")

    ? def makeSeries := <elang:control.makeSeries>

/**
 * Inspired by <a href=
 * "http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node347.html">Series</a>.
 * <p>
 * An RColl is an EIteratable we rely on 1) not to retain the assocFunc
 * argument to iterate/2 once iterate/2 exits (whether normally or otherwise),
 * and 2) to ignore the value returned by the assocFunc.
 * <p>
 * This module must only use the RCollStamp to approve EIteratables with this
 * property, and must not let this stamp escape.
 */
interface RColl guards RCollStamp extends EIteratable {}

def adapt1to2(oneArgFn) :any {
    return fn _,v { oneArgFn(v) }
}

/**
 *
 */
def makeSeries {

    /**
     * Makes a Series from any EIteratable
     */
    to run(coll :EIteratable) :EIteratable {
        if (coll =~ rcoll :RColl) {
            return makeSeries.fromRColl(rcoll)
        }
        def rcoll implements RCollStamp {
            to iterate(var assocFn) :void {
                try {
                    coll.iterate(fn k,v {
                        assocFn(k,v)
                        null
                    })
                } finally {
                    assocFn := Ref.broken("loop body disabled")
                }
            }
        }
        return makeSeries.fromRColl(rcoll)
    }

    /**
     * Make the infinite series of all the natural numbers in ascending order.
     * <p>
     * To avoid a non-termination, compose with an "until" transducer before
     * collecting.
     */
    to naturalNums() :EIteratable {
        def alephNull implements RCollStamp {
            to iterate(assocFunc) :void {
                var i := 0
                while (true) {
                    assocFunc(i, i)
                    i += 1
                }
            }
        }
        return makeSeries.fromRColl(alephNull)
    }

    /**
     * Makes a series from an EIteratable we can rely on to implement the
     * RColl lifetime guarantees.
     * <p>
     * Expected to be for internal use only. (XXX Perhaps we should refactor
     * so this isn't exposed?)
     */
    to fromRColl(rcoll :RColl) :EIteratable {

        /**
         * Paraphrasing the introduction of <a href=
         * "http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node347.html"
         * >Series</a> which inspired ours:
         * <blockquote>
         * Series combine aspects of sequences, streams, and loops. Like
         * sequences, series represent totally ordered multi-sets of key-value
         * pairs. The series methods operate on whole series, rather than
         * extracting elements to be processed by other functions.
         * <p>
         * Like streams, series can represent unbounded sets of pairs and are
         * supported by on-demand evaluation: each element of a series is not
         * computed until it is needed.
         * </blockquote>
         * A series has two kinds of methods: collectors, which iterate the
         * series, and transducers which build new derived series from a given
         * base series. (Waters' remaining category, "scanners", is taken care
         * of by our makeSeries/1 function for building a series from a
         * non-series, and by makeSeries#naturalNums/0.)
         * <p>
         * Transducers accumulate their function arguments and those of their
         * base series into their derived series. The lifetime of one of these
         * function arguments includes the lifetimes of all series derived
         * from it.
         * <p>
         * Collectors iterate the series, potentially calling the original
         * EIteratable and any of the functions accumulated into the series.
         * The series should encapsulate all these, and ensure that they are
         * called only during a call to one of its collect methods.
         * <p>
         * The current E implementation of series does not do the kind of
         * optimization done by Waters. But it is written to enable the kind
         * of binding-time stage separation needed for partial evaluation
         * to unroll static compositions of transducers + a collector into an
         * efficient nested loop. This should produce much of the net effect.
         * Hopefully, we'll eventually find out.
         *
         * @see <a href=
         * "http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node347.html"
         * >Series</a> by Richard Waters, appearing as Appendix A of
         * Common Lisp the Language by Guy Steele.
         */
        def series extends rcoll implements EIteratable {

            /**
             * Collects a list of the values of the series
             */
            to asList() :List {
                def result := [].diverge()
                rcoll.iterate(fn _,v {
                    result.push(v)
                })
                return result.snapshot()
            }

            /**
             * Collects a map of the key-value associations of the series.
             * <p>
             * If there are multiple associations for the same key, the last
             * one wins.
             */
            to asMap() :Map[any,any] {
                def result := [].asMap().diverge()
                rcoll.iterate(fn k,v {
                    result[k] := v
                })
                return result.snapshot()
            }

            /**
             * Collects a left-fold by repeated application of a binary
             * function. Seed should typically be the identity element for
             * that function.
             * <p>
             ? makeSeries(2..4).fold(0, fn x,y{x+y})
             # value: 9
             *
             ? makeSeries(2..4).fold("x", fn x,y{`$x$y`})
             # value: "x234"
             */
            to fold(seed, fold2Fn) :any {
                var result := seed
                rcoll.iterate(fn _,v {
                    result := fold2Fn(result, v)
                })
                return result
            }

            to sum() :int {
                return series.fold(0, fn x,y {x+y})
            }

            /**
             * Collects nothing from the series, but does iterate it, in order
             * to cause whatever side effects that causes.
             */
            to each2(assocFn) :void {
                rcoll.iterate(assocFn)
            }

            /**
             * Collects nothing from the series, but does iterate it, in order
             * to cause whatever side effects that causes.
             */
            to each(each1Fn) :void {
                rcoll.iterate(adapt1to2(each1Fn))
            }

            /**
             * Transduces into the subset for which test2Pred(k,v) passes.
             */
            to filter2(test2Pred) :EIteratable {
                def filtered implements RCollStamp {
                    to iterate(assocFn) :void {
                        rcoll.iterate(fn k,v {
                            if (test2Pred(k,v)) {
                                assocFn(k, v)
                            }
                        })
                    }
                }
                return makeSeries.fromRColl(filtered)
            }

            /**
             * Transduces into the subset for which test1Pred(v) passes.
             * <p>
             * Like Smalltalk's #select:
             */
            to filter(test1Pred) :any {
                return series.filter2(adapt1to2(test1Pred))
            }

            /**
             * Transduces into the subset until test2Pred(k,v) passes.
             */
            to until2(test2Pred) :EIteratable {
                def untiller implements RCollStamp {
                    to iterate(assocFn) :void {
                        rcoll.iterate(fn k,v {
                            if (test2Pred(k,v)) {
                                return
                            }
                            assocFn(k, v)
                        })
                    }
                }
                return makeSeries.fromRColl(untiller)
            }

            /**
             * Transduces into the subset until test1Pred(v) passes.
             */
            to until(test1Pred) :any {
                return series.until2(adapt1to2(test1Pred))
            }

            /**
             * Transduces into a series mapping from the same keys to
             * the values resulting from map2Fn(k,v).
             */
            to map2(map2Fn) :any {
                def mapped implements RCollStamp {
                    to iterate(assocFn) :void {
                        rcoll.iterate(fn k,v {
                            assocFn(k, map2Fn(k,v))
                        })
                    }
                }
                return makeSeries.fromRColl(mapped)
            }

            /**
             * Transduces into a series mapping from the same keys to
             * the values resulting from map1Fn(v).
             * <p>
             * Like Smalltalk's #collect:
             */
            to map(map1Fn) :any {
                return series.map2(adapt1to2(map1Fn))
            }

            /**
             * Given a iter2Fn function that produces an EIteratable from a
             * k,v pair, splice2 transduces into a series that's a one level
             * flattening of each of the series produced by the associations
             * in its base series.
             */
            to splice2(iter2Fn) :any {
                def splicer implements RCollStamp {
                    to iterate(assocFunc) :void {
                        rcoll.iterate(fn k,v {
                            makeSeries(iter2Fn(k,v)).iterate(assocFunc)
                        })
                    }
                }
                return makeSeries.fromRColl(splicer)
            }

            /**
             * Given a iter1Fn function that produces an EIteratable from a
             * value, splice transduces into a series that's a one level
             * flattening of each of the series produced by the values
             * in its base series.
             */
            to splice(iter1Fn) :any {
                return series.splice2(adapt1to2(iter1Fn))
            }
        }
        return series
    }
}
