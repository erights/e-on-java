#!/usr/bin/env rune

pragma.syntax("0.9")

# Copyright 2009 Teleometry Design under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def swt__uriGetter := <import:org.eclipse.swt.*>
def widget__uriGetter := <swt:widgets.*>
def custom__uriGetter := <swt:custom.*>
def SWT := <swt:makeSWT>

def swtType__uriGetter := <type:org.eclipse.swt.*>
def widgetType__uriGetter := <swtType:widgets.*>

def <swttools> := <import:org.erights.e.ui.swt.*>
def swtGrid__quasiParser := <swttools:swtGridQParserMaker>()
def M := <swttools:menuKit>

def makeLamportSlot := <elib:slot.makeLamportSlot>
def whenever := <elib:slot.whenever>
def EverReporter := <type:org.erights.e.elib.slot.EverReporter>

def makeOutlineView := <import:org.erights.e.tools.causeway.makeOutlineView>

def makeMessageOrderView(swtParent, palette,
                         abstractAction,
                         moModel,
                         selectionModel, searchModel,
                         vatMap, graphWalker) :near {
    
    # Useful maps for lookups in event handling.
    def itemToModelMap := [].asMap().diverge()
    def modelToItemMap := [].asMap().diverge()
    
    def seen := [].asSet().diverge()
    
    def buildTreeFromNode
    def buildTreeFromEdge(swtParent, palette,
                          edge, ndx,
                          vatMap, graphWalker) :void {
        
        if (seen.contains(edge)) {
            return;
        }
        seen.addElement(edge)
        
        def swtItem := <widget:makeTreeItem>(swtParent, 0)
        itemToModelMap.put([swtItem, ndx], edge, true)
        modelToItemMap.put(edge, [swtItem, ndx], true)
        graphWalker.labelItem(vatMap, edge, 0, swtItem)
        
        def target := edge.getTarget()
        buildTreeFromNode(swtItem, palette,
                          target, ndx,
                          vatMap, graphWalker,
                          target.getNextIn() != edge)
    }
    
    bind buildTreeFromNode(swtParent, palette,
                           node, ndx,
                           vatMap, graphWalker,
                           skipKids :boolean) :void {
        
        if (node.getID()[0] == "bottom") { return }
        
        def swtGotItem := <widget:makeTreeItem>(swtParent, 0)
        itemToModelMap.put([swtGotItem, ndx], node, true)
        graphWalker.labelItem(vatMap, node, 0, swtGotItem)
        
        # check for multiple senders
        if (node.getIncomingCount() > 1) {
            swtGotItem.setImage(palette.getImage("multiples"))
            # if not last edge, don't show kids
            if (skipKids) {
                return
            }
        }
        # Only map the "real" appearance of node
        modelToItemMap.put(node, [swtGotItem, ndx], true)
        for ge => gt in node.outs() {
            buildTreeFromEdge(swtParent, palette,
                              ge, ndx,
                              vatMap, graphWalker)
        }
    }
    
    def makeMOPane(swtParent, palette,
                   graph, ndx, selectionModel,
                   vatMap, graphWalker) :near {
        
        def swtPane := <widget:makeComposite>(swtParent, 0)
        def swtTree := <widget:makeTree>(swtPane,
                                         SWT.getSINGLE() |
                                           (SWT.getH_SCROLL() |
                                              SWT.getV_SCROLL()))
        
        def mopPalette := palette. makeMessageTreePalette()
        swtPane.setForeground(mopPalette.getFg())
        swtPane.setBackground(mopPalette.getBg())
        swtPane.setFont(mopPalette.getFont())
        swtTree.setForeground(mopPalette.getFg())
        swtTree.setBackground(mopPalette.getBg())
        swtTree.setFont(mopPalette.getFont())
        
        buildTreeFromNode(swtTree, palette,
                          graph, ndx,
                          vatMap, graphWalker,
                          false)
        
        # handle swt user events
        def swtSelectionListener {
            to widgetSelected(swtEvent) :void {
                def swtItem := swtEvent.getItem()
                def element := itemToModelMap.fetch([swtItem, ndx], fn{})
                selectionModel.setOptElement(element)
            }
            to widgetDefaultSelected(swtEvent) :void {}
        }
        swtTree.addSelectionListener(swtSelectionListener)
        
        def mop {
            
            to getPane() :near { return swtPane }
            
            to getWidget() :near { return swtTree }
            
            to activate() :void {}
            
            to layout() :void {
                
                swtGrid`${swtPane}:
                        ${swtTree}.X.Y`
                
                palette.zeroMargins(swtPane.getLayout())
            }
        }
        return mop
    }
    
    
    def swtMOView := <widget:makeComposite>(swtParent, 0)
    
    def fPalette := palette. makeFolderPalette()
    
    swtMOView.setForeground(fPalette.getFg())
    swtMOView.setBackground(fPalette.getBg())
    swtMOView.setFont(fPalette.getFont())
    
    def getActionTargets
    def outlineView := makeOutlineView(swtMOView, palette,
                                       abstractAction, getActionTargets)
    
    def swtFolder := <widget:makeTabFolder>(swtMOView, 0)
    swtFolder.setForeground(fPalette.getFg())
    swtFolder.setBackground(fPalette.getBg())
    swtFolder.setFont(fPalette.getFont())
    
    def tabKeeper := [].diverge()
    
    def swtTab := <widget:makeTabItem>(swtFolder, 0)
    
    def mop := makeMOPane(swtFolder, palette,
                          moModel, swtFolder.indexOf(swtTab), selectionModel,
                          vatMap, graphWalker)
    
    swtTab.setControl(mop.getPane())
    swtTab.setText("Message Order Tree")
    tabKeeper[swtFolder.indexOf(swtTab)] := [swtTab, mop]
    
    # select top item & expand tree as default selection
    swtFolder.setSelection(swtFolder.indexOf(swtTab))
    def swtItems := mop.getWidget().getItems()
    if (swtItems.size() > 0) {
        mop.getWidget().setSelection([swtItems[0]])
        outlineView.expandTree(mop.getWidget())
    }
    
    # context menu for mop
    [def doFindMultiples,
     def doFindSomething,
     
     def doGoTo]
    
    bind doFindMultiples extends abstractAction(doFindMultiples) {
        to run() :void {
            def ndx := swtFolder.getSelectionIndex()
            if (ndx != -1) {
                def [_, mop] := tabKeeper[ndx]
                def swtItems := mop.getWidget().getSelection()
                if (swtItems.size() > 0) {
                    def element := itemToModelMap.fetch([swtItems[0], ndx], fn{})
                    if (element != null) {
                        searchModel.findMultiples(element, 
                                                  swtItems[0].getText())
                    }
                }
            }
        }
        to getLabel()            :String { return "&Find Multiples" }
        to getOptTip()           :String { 
            return "Finds all senders for this target" 
        }
    }
    
    bind doFindSomething extends abstractAction(doFindSomething) {
        to run() :void {
            #traceline("doFindSomething()")
        }
        to getLabel()            :String { return "&Find Something" }
        to everEnabledReporter() :EverReporter {
            return whenever([], fn{false})
        }
    }
    
    bind doGoTo extends abstractAction(doGoTo) {
        to run() :void {
            #traceline("doGoTo()")
        }
        to getLabel()            :String { return "&Go To" }
        to everEnabledReporter() :EverReporter {
            return whenever([], fn{false})
        }
    }
    
    def menuAction := M.menu([doFindMultiples,
                              doFindSomething,
                              M.sep(),
                              doGoTo])
    
    def menuMap := [].asMap().diverge()
    
    def swtContextMenu := menuAction.makeMenu(mop.getWidget(), menuMap)
    
    # participate in synchronized selection across views
    def selectionObserver {
        to placeSelected(optPlace) :void {
            if (optPlace != null && optPlace =~ [element, _]) {
                def tabbedItem := modelToItemMap.fetch(element, fn{})
                if (tabbedItem != null) {
                    def [swtItem, ndx] := tabbedItem
                    swtFolder.setSelection(ndx)
                    def [_, mop] := tabKeeper[ndx]
                    mop.getWidget().setSelection([swtItem])
                    mop.getWidget().showItem(swtItem)
                }
            }
        }
    }
    selectionModel.addObserver(selectionObserver)
    
    def getCurrentTree() :near {
        def ndx := swtFolder.getSelectionIndex()
        if (ndx != -1) {
            def [_, mop] := tabKeeper[ndx]
            return mop.getWidget()
        }
        return null
    }
    
    bind getActionTargets(_ :String) :List {
        def swtTree := getCurrentTree()
        if (null != swtTree) {
            return [swtTree]
        }
        return null
    }
    
    def mov {
        
        to open() :void {}
        
        to layout() :void {
            
            outlineView.layout()
            
            for [_, mop] in tabKeeper {
                mop.layout()
            }
            
            swtGrid`${swtMOView}:
                    ${outlineView.getTopLevelSWTControl()}.X
                    ${swtFolder}.X.Y`
        }
        
        # exportModelToDotFile starts with the currently select mov item
        to getSelectionModel() :near {
            def swtTree := getCurrentTree()
            if (null != swtTree) {
                def selection := swtTree.getSelection()
                if (selection.size() > 0) {
                    def ndx := swtFolder.getSelectionIndex()
                    def element := itemToModelMap.fetch([selection[0], ndx], fn{})
                    if (element != null) {
                        if (element.isNode()) {
                            return element
                        } else {
                            return element.getTarget()
                        }
                    }
                }
            }
            return null
        }
    }
    return mov
}
