#!/usr/bin/env rune

pragma.syntax("0.9")

# Copyright 2008 Teleometry Design under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def swt__uriGetter := <import:org.eclipse.swt.*>
def widget__uriGetter := <swt:widgets.*>
def custom__uriGetter := <swt:custom.*>
def SWT := <swt:makeSWT>

def swtType__uriGetter := <type:org.eclipse.swt.*>
def widgetType__uriGetter := <swtType:widgets.*>

def <swttools> := <import:org.erights.e.ui.swt.*>
def swtGrid__quasiParser := <swttools:swtGridQParserMaker>()
def M := <swttools:menuKit>

def makeLamportSlot := <elib:slot.makeLamportSlot>
def whenever := <elib:slot.whenever>
def EverReporter := <type:org.erights.e.elib.slot.EverReporter>

def makeOutlineView := <import:org.erights.e.tools.causeway.makeOutlineView>

def makeWatcher() :near {
    def items := [].asSet().diverge()
    
    def watcher {
        
        to see(item) :void {
            items.addElement(item)
        }
        
        to hasSeen(item) :boolean {
            return items.contains(item)
        }
    }
    return watcher
}

# Useful maps for lookups in event handling.
def itemToModelMap := [].asMap().diverge()
def modelToItemMap := [].asMap().diverge()

def buildTree(swtParent, palette,
              edge, ndx,
              vatMap, graphWalker,
              watcher) :void {
    
    if (watcher.hasSeen(edge)) {
        return;
    }
    watcher.see(edge)
    
    def swtItem := <widget:makeTreeItem>(swtParent, 0)
    itemToModelMap.put([swtItem, ndx], edge, true)
    modelToItemMap.put(edge, [swtItem, ndx], true)
    graphWalker.labelItem(vatMap, edge, swtItem)

    def target := edge.getTarget()
    if (target.getID()[0] == "bottom") { return }
        
    def swtGotItem := <widget:makeTreeItem>(swtItem, 0)
    itemToModelMap.put([swtGotItem, ndx], target, true)
    graphWalker.labelItem(vatMap, target, swtGotItem)
        
    # check for multiple senders
    if (target.getIncomingCount() > 1) {
        swtGotItem.setImage(palette.getImage("multiples"))
        # if not last edge, don't show kids
        if (target.getNextIn() != edge) {
            return
        }
    }
    # Only map the "real" appearance of target
    modelToItemMap.put(target, [swtGotItem, ndx], true)
    for ge => _ in target.outs() {
        buildTree(swtItem, palette,
                  ge, ndx,
                  vatMap, graphWalker,
                  watcher)
    }
}

def makeMOPane(swtParent, palette,
               graph, ndx, selectionModel,
               vatMap, graphWalker) :near {
    
    def swtPane := <widget:makeComposite>(swtParent, 0)
    def swtTree := <widget:makeTree>(swtPane,
                                     SWT.getSINGLE() |
                                       (SWT.getH_SCROLL() |
                                          SWT.getV_SCROLL()))

    def mopPalette := palette. makeMessageTreePalette()
    swtPane.setForeground(mopPalette.getFg())
    swtPane.setBackground(mopPalette.getBg())
    swtPane.setFont(mopPalette.getFont())
    swtTree.setForeground(mopPalette.getFg())
    swtTree.setBackground(mopPalette.getBg())
    swtTree.setFont(mopPalette.getFont())

    def watcher := makeWatcher()
    for  edge => _ in graph.outs() {
        buildTree(swtTree, palette,
                  edge, ndx,
                  vatMap, graphWalker,
                  watcher)
    }
    
    def swtSelectionListener {
        to widgetSelected(swtEvent) :void {
            def swtItem := swtEvent.getItem()
            def element := itemToModelMap.fetch([swtItem, ndx], fn{})
            selectionModel.setOptElement(element)
        }
        to widgetDefaultSelected(swtEvent) :void {}
    }
    swtTree.addSelectionListener(swtSelectionListener)
    
    def mop {
        
        to getPane() :near { return swtPane }
        
        to getWidget() :near { return swtTree }
        
        to activate() :void {}
        
        to layout() :void {
            
            swtGrid`${swtPane}:
                        ${swtTree}.X.Y`
            
            palette.zeroMargins(swtPane.getLayout())
        }
    }
    return mop
}

def makeMessageOrderView(swtParent, palette,
                         abstractAction,
                         moModel, selectionModel,
                         vatMap, graphWalker) :near {
    
    def swtMOView := <widget:makeComposite>(swtParent, 0)

    def fldrPalette := palette. makeFolderPalette()

    swtMOView.setForeground(fldrPalette.getFg())
    swtMOView.setBackground(fldrPalette.getBg())
    swtMOView.setFont(fldrPalette.getFont())

    def getActionTargets
    def outlineView := makeOutlineView(swtMOView, palette,
                                       abstractAction, getActionTargets)
    
    def swtFolder := <widget:makeTabFolder>(swtMOView, 0)
    swtFolder.setForeground(fldrPalette.getFg())
    swtFolder.setBackground(fldrPalette.getBg())
    swtFolder.setFont(fldrPalette.getFont())

    def tabKeeper := [].diverge()
    
    def swtTab := <widget:makeTabItem>(swtFolder, 0)
    
    def mop := makeMOPane(swtFolder, palette,
                          moModel, swtFolder.indexOf(swtTab), selectionModel,
                          vatMap, graphWalker)
    
    swtTab.setControl(mop.getPane())
    swtTab.setText("Message Order Tree")
    tabKeeper[swtFolder.indexOf(swtTab)] := [swtTab, mop]
    
    # default selection
    swtFolder.setSelection(swtFolder.indexOf(swtTab))
    def swtItems := mop.getWidget().getItems()
    if (swtItems.size() > 0) {
        mop.getWidget().setSelection([swtItems[0]])
        outlineView.expandTree(mop.getWidget())
    }
    
    def selectionObserver {
        to elementSelected(optElement) :void {
            def tabbedItem := modelToItemMap.fetch(optElement, fn{})
            if (tabbedItem != null) {
                def [swtItem, ndx] := tabbedItem
                swtFolder.setSelection(ndx)
                def [_, mop] := tabKeeper[ndx]
                mop.getWidget().setSelection([swtItem])
                mop.getWidget().showItem(swtItem)
            }
        }
    }
    selectionModel.addObserver(selectionObserver)
    
    def getCurrentTree() :near {
        def ndx := swtFolder.getSelectionIndex()
        if (ndx != -1) {
            def [_, mop] := tabKeeper[ndx]
            return mop.getWidget()
        }
        return null
    }
    
    bind getActionTargets(_ :String) :List {
        def swtTree := getCurrentTree()
        if (null != swtTree) {
            return [swtTree]
        }
        return null
    }
    
    def mov {
        
        to open() :void {}
        
        to layout() :void {
            
            outlineView.layout()
            
            for [_, mop] in tabKeeper {
                mop.layout()
            }
            
            swtGrid`${swtMOView}:
                    ${outlineView.getTopLevelPane()}.X
                    ${swtFolder}.X.Y`
        }
        
        to getSelectionModel() :near {
            def swtTree := getCurrentTree()
            if (null != swtTree) {
                def selection := swtTree.getSelection()
                if (selection.size() > 0) {
                    def ndx := swtFolder.getSelectionIndex()
                    def element := itemToModelMap.fetch([selection[0], ndx], fn{})
                    if (element != null) {
                        if (element.isNode()) {
                            return element
                        } else {
                            return element.getTarget()
                        }
                    }
                }
            }
            return null
        }
    }
    return mov
}
