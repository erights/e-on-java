#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def swt__uriGetter := <import:org.eclipse.swt.*>
def widget__uriGetter := <swt:widgets.*>
def custom__uriGetter := <swt:custom.*>
def SWT := <swt:makeSWT>

def <swttools> := <import:org.erights.e.ui.swt.*>
def swtGrid__quasiParser := <swttools:swtGridQParserMaker>()

# Useful maps for lookups in event handling.
def itemToModelMap := [].asMap().diverge()
def modelToItemMap := [].asMap().diverge()

def getNestedEdges(origin, edges, offset) :List {
    def nested := [].diverge()
    
    for i in offset ..! edges.size() {
        def edge := edges[i]
        if (edge != null) {
            if (edge.getOrigin() == origin) {
                nested.push(edge)
            } else {
                return nested.snapshot()
            }
        }
    }
    return nested.snapshot()
}

def labelNodeItem(vatMap, node, item) :void {
    def [vatName, turn] := node.getID()
    
    # Set descriptive text to vat name and turn.
    def attr := vatMap.fetchDisplayAttributes(vatName)
    item.setForeground(attr[1])
    item.setText(`[${attr[0]}, $turn]`)
}

def getEdgePart(edge) :String {
    def [sc, _] := edge.getContext()
    # find most specific sending context event type
    if (sc != "") {
        def parts := sc.split(".")
        if (parts.size() >= 1) {
            def part := parts.last()
            switch (part) {
                match `Sent` { return " ->" }
                match `SentIf` { return " ..." }
                match `Comment` { return "" }
                match _ { return ` ($part)` }
            }
        }
    }
    return ":"
}

def labelArcItem(vatMap, edge, item) :void {
    def [tVatName, tTurn] := edge.getTarget().getID()
    
    # Set descriptive text to vat name and turn.
    def tAttr := vatMap.fetchDisplayAttributes(tVatName)
    item.setForeground(tAttr[1])
    def part := getEdgePart(edge)
    def msg := edge.getMessage()
    if (tAttr[0] == "ether") {
        item.setText(`$msg$part`)
    } else {
        item.setText(`$msg$part [${tAttr[0]}, $tTurn]`)
    }
}

def buildTreeItems(parent, palette, origin, arcs, vatMap, traceline) : void {
    
    # Make tree item for origin.
    def item := <widget:makeTreeItem>(parent, 0)
    labelNodeItem(vatMap, origin, item)
    
    for i in 0 ..! arcs.size() {
        
        def arc := arcs[i]
        
        # Make nested tree item for arc.
        def nested := <widget:makeTreeItem>(item, 0)
        
        itemToModelMap.put(nested, arc, true)
        modelToItemMap.put(arc, nested, true)
        
        labelArcItem(vatMap, arc, nested)
    }
}

def buildPOTree(parent, palette, poList, vatMap, traceline) :void {
    
    var i := 0
    while (i < poList.size()) {
        
        def edge := poList[i]
        if (edge != null) {
            def origin := edge.getOrigin()
            # nested will contain at least one edge
            def nested := getNestedEdges(origin, poList, i)
            buildTreeItems(parent, palette, origin, nested, vatMap, traceline)
            
            i += nested.size()
            
        } else {
            i := i +1
        }
    }
}

def poTreePaneAuthor(traceline) :near {
    
    def makePOTreePane(parent, palette, poList, vatName, vatMap, messageTreePane) :near {
        
        def pane := <widget:makeComposite>(parent, 0)
        def tree := <widget:makeTree>(pane,
                                      SWT.getSINGLE() |
                                        (SWT.getH_SCROLL() | SWT.getV_SCROLL()))
        
        def potp := palette.makePOTreePalette()
        tree.setForeground(potp.getFg())
        tree.setBackground(potp.getBg())
        tree.setFont(potp.getFont())
        
        buildPOTree(tree, palette, poList, vatMap, traceline)
        
        def listenerForMessageTree {
            to widgetSelected(event) :void {
                def item := event.getItem()
                def edge := itemToModelMap.fetch(item, fn{})
                if (edge != null) {
                    messageTreePane.syncSelect(edge)
                }
            }
            to widgetDefaultSelected(event) :void {}
        }
        
        tree.addSelectionListener(listenerForMessageTree)
        
        def poTreePane {
            
            to getPane() :near { return pane }
            
            to getWidget() :near { return tree }
            
            to activate() :void {}
            
            to layout() :void {
                
                swtGrid`${pane}:
                        ${tree}.X.Y`
                
                pane.getLayout().setMarginWidth(0)
                pane.getLayout().setMarginHeight(0)
                pane.getLayout().setHorizontalSpacing(0)
                pane.getLayout().setVerticalSpacing(0)
            }
            
            to getTabLabel() :String {
                def [name, _] := vatMap.fetchDisplayAttributes(vatName)
                return name
            }
        }
        return poTreePane
    }
}
