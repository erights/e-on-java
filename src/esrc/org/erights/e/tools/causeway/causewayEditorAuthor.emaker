#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def swt__uriGetter := <import:org.eclipse.swt.*>
def widget__uriGetter := <swt:widgets.*>
def custom__uriGetter := <swt:custom.*>
def SWT := <swt:makeSWT>

def swtType__uriGetter := <type:org.eclipse.swt.*>
def widgetType__uriGetter := <swtType:widgets.*>
def Shell    := <widgetType:Shell>
def Menu     := <widgetType:Menu>
def MenuItem := <widgetType:MenuItem>
def ToolBar  := <widgetType:ToolBar>
def ToolItem := <widgetType:ToolItem>
def ShellListener := <swtType:events.ShellListener>

def sky__uriGetter := <import:com.skyhunter.*>

def <swttools> := <import:org.erights.e.ui.swt.*>
def swtGrid__quasiParser := <swttools:swtGridQParserMaker>()
def M := <swttools:menuKit>

def paletteAuthor := <import:org.erights.e.tools.causeway.paletteAuthor>

def makeLamportSlot := <elib:slot.makeLamportSlot>
def whenever := <elib:slot.whenever>
def EverReporter := <type:org.erights.e.elib.slot.EverReporter>

def __versionLauncherAuthor := <elang:launcher.__versionLauncherAuthor>

def causewayEditorAuthor(rezKit,
                         abstractAction,
                         makers, openners,
                         <file>, <jar>, props,
                         activate, shutdown,
                         tcr,
                         traceline) :near {
    
    def makeDialogVow := <sky:swt.makeDialogVowAuthor>(rezKit,
                                                       makers.get("frame")(),
                                                       traceline)
    def editorShellListener :ShellListener := def _ {
        to shellClosed(event) :void { shutdown() }
        to shellActivated(event) :void {}
        to shellDeactivated(event) :void {}
        to shellIconified(event) :void {}
        to shellDeiconified(event) :void {}
    }
    
    def makeCausewayEditor(var rootDirName :String, traces :List) :near {
        
        def causewayEditor
        
        def editorShell := makers.get("frame")()
        editorShell.addShellListener(editorShellListener)
        def makePalette := paletteAuthor(rezKit, makers, traceline)
        def palette := makePalette()
        
        var hasMetrics := false
        def listenerForMetrics {
            to paintControl(event) :void {
                hasMetrics := palette.setMetrics(event.getGc())
            }
        }
        editorShell.addPaintListener(listenerForMetrics)
        
#        if (hasMetrics) {
#            editorShell.removePaintListener(listenerForMetrics)
#        }
        
        def fp := palette.makeFramePalette()
        editorShell.setForeground(fp.getFg())
        editorShell.setBackground(fp.getBg())
        editorShell.setFont(fp.getFont())
        
        #def statusBar := <widget:makeLabel>(editorShell, 0)
        #statusBar.setText("Causeway's internal status messages displayed here...")
        
        def debugln(str) :void {
            traceline(str)
            #statusBar.setText(str)
        }
        
        # menuFile
        [def doOpen,
         def doClose,
         
         def doSetSourceRoot,
         
         def doExport,
         
         def doPageSetup,
         def doPrint,
         
         def doExit]
        
        # menuSearch
        [def doFind,
         def doFindNext,
         def doFindPrevious,
         
         def doGoTo]
        
        # menuView
        [def doSmallerFont,
         def doLargerFont]
        
        # menuTools
        [def doDevoraOne,
         def doDevoraTwo,
         
         def doFilterOptions]
        
        # menuWindows
        [def doNextTab,
         def doPreviousTab]
        
        # menuHelp
        [def doHelpTopics,
         
         def doAbout]
        
        /**
         *
         */
        bind doOpen extends abstractAction(doOpen) {
            to run() :void {
                def waitCursor := makers["cursor"](SWT.getCURSOR_WAIT())
                def oldEditorShell := causewayEditor.getEditorShell()
                var optPaths :List := openners["openFile"](oldEditorShell)
                if (optPaths != []) {
                    if (rootDirName == "") {
                        doSetSourceRoot()
                    }
                    oldEditorShell.removeShellListener(editorShellListener)
                    oldEditorShell.setCursor(waitCursor)
                    def openAction() :void {
                        def editor := makeCausewayEditor(rootDirName,
                                                         optPaths)
                        editor.open()
                        oldEditorShell.close()
                        # dispose ?
                    }
                    openAction <- run()
                }
            }
            to getLabel()            :String { "&Open..." }
            to getOptMenuAccelDesc() :String { "Ctrl+O" }
            to getOptTip()           :String { "Open a file" }
            to getOptIconFQName()    :String {
                "com/skyhunter/e/icons/fileOpen.gif"
            }
        }
        
        /**
         *
         */
        bind doClose extends abstractAction(doClose) {
            to run() :void {
                debugln("doClose()")
            }
            to getLabel()            :String { "&Close" }
            to getOptMenuAccelDesc() :String { "Ctrl+W" }
            to getOptTip()           :String { "Closes the editor" }
            to everEnabledReporter() :EverReporter {
                whenever([], fn{false})
            }
        }
        
        /**
         *
         */
        bind doExport extends abstractAction(doExport) {
            to run() :void {
                def waitCursor := makers["cursor"](SWT.getCURSOR_WAIT())
                def editorShell := causewayEditor.getEditorShell()
                
                def dotFile := openners["exportFile"](editorShell,
                                                      "messageGraph.gv", [])
                
                if (dotFile != null) {
                    editorShell.setCursor(waitCursor)
                    try {
                        causewayEditor.getViewer().exportModelToDotFile(dotFile)
                    } finally {  # set cursor to default cursor
                        editorShell.setCursor(null)
                    }
                }
            }
            to getLabel()            :String { "&Export..." }
            to getOptTip()           :String {
                "Export message graph to GraphViz DOT format"
            }
        }
        
        /**
         *
         */
        bind doPageSetup extends abstractAction(doPageSetup) {
            to run() :void {
                debugln("doPageSetup()")
            }
            to getLabel()            :String { "Page Set&up..." }
            to getOptTip()           :String { "Printing preferences" }
            to everEnabledReporter() :EverReporter {
                whenever([], fn{false})
            }
        }
        
        /**
         *
         */
        bind doPrint extends abstractAction(doPrint) {
            to run() :void {
                debugln("doPrint()")
            }
            to getLabel()            :String { "&Print..." }
            to getOptMenuAccelDesc() :String { "Ctrl+P" }
            to getOptTip()           :String { "Prints this file" }
            to getOptIconFQName()    :String {
                "com/skyhunter/e/icons/print16-16.gif"
            }
            to everEnabledReporter() :EverReporter {
                whenever([], fn{false})
            }
        }
        
        /**
         *
         */
        bind doExit extends abstractAction(doExit) {
            to run() :void {
                debugln("doExit()")
            }
            to getLabel()            :String { "E&xit" }
            to getOptMenuAccelDesc() :String { "Ctrl+Q" }
            to getOptTip()           :String { "Shuts down these editors" }
        }
        
        /**
         *
         */
        bind doFind extends abstractAction(doFind) {
            to run() :void {
                debugln("doFind()")
            }
            to getLabel()            :String { "Find..." }
            to getOptMenuAccelDesc() :String { "Ctrl+F" }
            to getOptTip()           :String {
                "Find"
            }
            to getOptIconFQName()    :String {
                "com/skyhunter/e/icons/find16-16.gif"
            }
            to everEnabledReporter() :EverReporter {
                whenever([], fn{false})
            }
        }
        
        /**
         *
         */
        bind doFindNext extends abstractAction(doFindNext) {
            to run() :void {
                debugln("doFindNext()")
            }
            to getLabel()            :String { "Find &Next" }
            to getOptMenuAccelDesc() :String { "F3" }
            to getOptTip()           :String { "Find the next one" }
            to everEnabledReporter() :EverReporter {
                whenever([], fn{false})
            }
        }
        
        /**
         *
         */
        bind doFindPrevious extends abstractAction(doFindPrevious) {
            to run() :void {
                debugln("doFindPrevious()")
            }
            to getLabel()            :String { "Find &Previous" }
            to getOptMenuAccelDesc() :String { "Shift+F3" }
            to getOptTip()           :String { "Find the previous one" }
            to everEnabledReporter() :EverReporter {
                whenever([], fn{false})
            }
        }
        
        /**
         *
         */
        bind doGoTo extends abstractAction(doGoTo) {
            to run() :void {
                debugln("doGoTo()")
            }
            to getLabel()            :String { "&Go To..." }
            to getOptMenuAccelDesc() :String { "Ctrl+G" }
            to getOptTip()           :String {
                "Go to a line number"
            }
            to getOptIconFQName()    :String {
                "com/skyhunter/e/icons/goto16-16.gif"
            }
            to everEnabledReporter() :EverReporter {
                whenever([], fn{false})
            }
        }
        
        /**
         *
         */
        bind doSmallerFont extends abstractAction(doSmallerFont) {
            to run() :void {
                debugln("doSmallerFont()")
            }
            to getLabel()            :String { return "&SmallerText" }
            to getOptTip()           :String { return "Make text smaller" }
            to everEnabledReporter() :EverReporter {
                whenever([], fn{false})
            }
        }
        
        /**
         *
         */
        bind doLargerFont extends abstractAction(doLargerFont) {
            to run() :void {
                debugln("doLargerFont()")
            }
            to getLabel()            :String { return "&LargerText" }
            to getOptTip()           :String { return "Make text larger" }
            to getOptIconFQName()    :String {
                return "com/skyhunter/e/icons/magnify.gif"
            }
            to everEnabledReporter() :EverReporter {
                whenever([], fn{false})
            }
        }
        
        /**
         *
         */
        bind doDevoraOne extends abstractAction(doDevoraOne) {
            to run() :void {
                debugln("doDevoraOne()")
            }
            to getLabel()            :String { "&Devora (pass 1)" }
            to getOptTip()           :String { "Run Devora filter" }
            to everEnabledReporter() :EverReporter {
                whenever([], fn{false})
            }
        }
        
        /**
         *
         */
        bind doDevoraTwo extends abstractAction(doDevoraTwo) {
            to run() :void {
                debugln("doDevoraTwo()")
            }
            to getLabel()            :String { "&Devora (pass 2)" }
            to getOptTip()           :String { "Run Devora filter" }
            to everEnabledReporter() :EverReporter {
                whenever([], fn{false})
            }
        }
        
        /**
         *
         */
        bind doFilterOptions extends abstractAction(doFilterOptions) {
            to run() :void {
                
                def CANCEL := 0
                def SAVE := 1
                def UPDATE_VIEWER := 2
                
                def action := causewayEditor.getViewer().showFilterOptions()
                when (action) -> {
                    if (action == UPDATE_VIEWER) {
                        causewayEditor.updateViewer()
                    }
                }
            }
            to getLabel()            :String { "&Set Filter Options..." }
            to getOptTip()           :String { "Set filter options" }
        }
        
        /**
         *
         */
        bind doSetSourceRoot extends abstractAction(doSetSourceRoot) {
            to run() :void {
                def dir := openners["openDir"](causewayEditor.getEditorShell(),
                                               "Select the source code root directory.")
                if (dir != null) {
                    rootDirName := dir.getPath()
                }
            }
            to getLabel()            :String { "&Set Source Root..." }
            to getOptTip()           :String {
                "Set source code root directory"
            }
        }
        
        /**
         *
         */
        bind doNextTab extends abstractAction(doNextTab) {
            to run() :void {
                debugln("doNextTab()")
            }
            to getLabel()            :String { "&Next Tab" }
            to getOptMenuAccelDesc() :String { "Ctrl+Tab" }
            to getOptTip()           :String { "Bring next to top" }
            to everEnabledReporter() :EverReporter {
                whenever([], fn{false})
            }
        }
        
        /**
         *
         */
        bind doPreviousTab extends abstractAction(doPreviousTab) {
            to run() :void {
                debugln("doPreviousTab()")
            }
            to getLabel()            :String { "&Previous Tab" }
            to getOptMenuAccelDesc() :String { "Shift+Ctrl+Tab" }
            to getOptTip()           :String { "Bring previous to top" }
            to everEnabledReporter() :EverReporter {
                whenever([], fn{false})
            }
        }
        
        /**
         *
         */
        bind doHelpTopics extends abstractAction(doHelpTopics) {
            to run() :void {
                debugln("doHelpTopics()")
            }
            to getLabel()            :String { "Help Topics..." }
            to getOptMenuAccelDesc() :String { "F1" }
            to getOptTip()           :String { "Helps clear up all confusion" }
            to getOptIconFQName()    :String {
                "com/skyhunter/e/icons/help.gif"
            }
        }
        
        /**
         *
         */
        bind doAbout extends abstractAction(doAbout) {
            to run() :void {
#                def appName := self.getAppName()
#                makeDialogVow(`About $appName`,
#                              term`text(b($appName),
#                                   "
                #by Terry Stanley and Mark S. Miller
                #
                #",
#                                   ${doAbout.getVersionString()})`,
#                              null,
#                              ["Ok"])
            }
            to getVersionString() :String {
                __versionLauncherAuthor.getOptVersionText(props)
            }
            to getLabel()  :String {
                ""
#                `&About ${self.getAppName()}...`
            }
            to getOptTip() :String { "What program is this?" }
        }
        
        def barAction :=
          M.bar([def menuFile :=
                   M.menu("&File",
                          [doOpen,
                           doClose,
                           M.sep(),
                           doSetSourceRoot,
                           M.sep(),
                           doExport,
                           M.sep(),
                           doPageSetup,
                           doPrint,
                           M.sep(),
                           doExit]),
                 def menuSearch :=
                   M.menu("Sea&rch",
                          [doFind,
                           doFindNext,
                           doFindPrevious,
                           M.sep(),
                           doGoTo]),
                 def menuView :=
                   M.menu("&View",
                          [doSmallerFont,
                           doLargerFont]),
                 def menuTools :=
                   M.menu("&Tools",
                          [doDevoraOne,
                           doDevoraTwo,
                           M.sep(),
                           doFilterOptions]),
                 def menuWindow :=
                   M.menu("&Window",
                          [doNextTab,
                           doPreviousTab]),
                 def menuHelp :=
                   M.menu("&Help",
                          [doHelpTopics,
                           M.sep(),
                           doAbout])])
        
        def menuMap := [].asMap().diverge()
        
        def viewerDirectorAuthor :=
          <import:org.erights.e.tools.causeway.viewerDirectorAuthor>
        def makeViewerDirector :=
          viewerDirectorAuthor(rootDirName,
                               <file>, <jar>, props,
                               makers, editorShell,
                               abstractAction, tcr, traceline)
        
        def viewerShellListener :ShellListener := def _ {
            to shellClosed(event) :void {}  # dispose ?
            to shellActivated(event) :void {}
            to shellDeactivated(event) :void {}
            to shellIconified(event) :void {}
            to shellDeiconified(event) :void {}
        }
        
        def makeViewerShell(parent, palette) :Shell {
            
            def vShell := makers.get("modelessDialog")(parent)
            vShell.addShellListener(viewerShellListener)
            
            def fp := palette.makeFramePalette()
            vShell.setForeground(fp.getFg())
            vShell.setBackground(fp.getBg())
            vShell.setFont(fp.getFont())
            
            return vShell
        }
        
        var viewerShell := makeViewerShell(editorShell, palette)
        
        def viewerDirector := makeViewerDirector(viewerShell,
                                                 palette,
                                                 traces)
        
        bind causewayEditor {
            to getAppName() :String { "Causeway" }
            to getEditorShell() :Shell { editorShell }
            to getViewerShell() :Shell { viewerShell }
            
            to getViewer() :near { viewerDirector.getView() }
            
            to updateViewer() :void {
                
                def waitCursor := makers["cursor"](SWT.getCURSOR_WAIT())
                def oldViewerShell := viewerShell
                oldViewerShell.removeShellListener(viewerShellListener)
                oldViewerShell.setCursor(waitCursor)
                
                def vShell := makeViewerShell(editorShell, palette)
                viewerDirector.updateView(vShell)
                
                oldViewerShell.setCursor(null)
                oldViewerShell.close()
                oldViewerShell.dispose()
                
                viewerShell := vShell
                
                causewayEditor.getViewer().layout()
                
                swtGrid`${causewayEditor.getViewerShell()}:
                        ${causewayEditor.getViewer().getTopLevelPane()}.X.Y`
                
                swtGrid`${causewayEditor.getEditorShell()}:
                        ${causewayEditor.getViewerShell()}.X.Y`
                
                #${causewayEditor.getViewer().getTopLevelPane()}.X.Y`
                #${causewayEditor.getStatusBar()}.X`
                
                palette.zeroMargins(causewayEditor.getEditorShell().getLayout())
                
                causewayEditor.getEditorShell().open()
                causewayEditor.getViewerShell().open()
                
                causewayEditor.getViewer().open()
            }
            
            /**
             *
             */
            to open() :void {
                
                causewayEditor.getViewer().layout()
                
                swtGrid`${causewayEditor.getViewerShell()}:
                        ${causewayEditor.getViewer().getTopLevelPane()}.X.Y`
                
                swtGrid`${causewayEditor.getEditorShell()}:
                        ${causewayEditor.getViewerShell()}.X.Y`
                
                #${causewayEditor.getViewer().getTopLevelPane()}.X.Y`
                #${causewayEditor.getStatusBar()}.X`
                
                palette.zeroMargins(causewayEditor.getEditorShell().getLayout())
                
                def menuBar := barAction.makeMenu(causewayEditor.getEditorShell(), menuMap)
                
                def appName := causewayEditor.getAppName()
                
                causewayEditor.getEditorShell().setText(`$appName`)
                
                causewayEditor.getEditorShell().open()
                causewayEditor.getViewerShell().open()
                
                causewayEditor.getViewer().open()
            }
        }
        return causewayEditor
    }
    return makeCausewayEditor
}
