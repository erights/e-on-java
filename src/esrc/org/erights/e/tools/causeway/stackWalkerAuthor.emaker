#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def swt__uriGetter := <import:org.eclipse.swt.*>
def widget__uriGetter := <swt:widgets.*>
def custom__uriGetter := <swt:custom.*>
def layout__uriGetter := <swt:layout.*>
def SWT := <swt:makeSWT>

def makeLamportSlot := <elib:slot.makeLamportSlot>
def whenever := <elib:slot.whenever>
def EverReporter := <type:org.erights.e.elib.slot.EverReporter>

def <swttools> := <import:org.erights.e.ui.swt.*>
def swtGrid__quasiParser := <swttools:swtGridQParserMaker>()

# [[start-line, start-col], [end-line, end-col]]
def SourceSpan := Tuple[Tuple[int,int], Tuple[int, int]]

# [filename, fncname]
def SourceName := Tuple[String, String]

# A [source-name, source-span]
def StackEntry := Tuple[SourceName, SourceSpan]

# top-to-bottom list of stack entries
def Stack := List[StackEntry]

def getText(file) :String {
    if (!(file.__respondsTo("exists",0)) || file.exists()) {
        file.getText()
    } else {
        `*** "${file.getPath()}" not found ***`
    }
}

def stackWalkerAuthor(<file>, <jar>, traceline) :near {
    
    def makeStackWalker(parent, makers, palette) :near {
        
        def sideToSideSash := <custom:makeSashForm>(parent, SWT.getHORIZONTAL())
        
        def stackPane := <widget:makeComposite>(sideToSideSash, SWT.getBORDER())
        def stack := <widget:makeList>(stackPane, SWT.getSINGLE())
        
        def sp := palette.makeEStackPalette()
        stackPane.setForeground(sp.getFg())
        stackPane.setBackground(sp.getBg())
        stackPane.setFont(sp.getFont())
        stack.setForeground(sp.getFg())
        stack.setBackground(sp.getBg())
        stack.setFont(sp.getFont())
        
        def dp := palette.makeDescPalette()
        
        def description := <custom:makeCLabel>(stackPane,
                                               SWT.getCENTER() | SWT.getSHADOW_OUT())
        description.setForeground(dp.getFg())
        description.setBackground(dp.getBg())
        description.setFont(dp.getFont())
        
        def esp := palette.makeECodePalette()
        def sourcePane := <widget:makeComposite>(sideToSideSash, SWT.getBORDER())
        sourcePane.setForeground(esp.getFg())
        sourcePane.setBackground(esp.getBg())
        sourcePane.setFont(esp.getFont())
        def source := <custom:makeStyledText>(sourcePane,
                                              SWT.getH_SCROLL() | SWT.getV_SCROLL())
        source.setForeground(esp.getFg())
        source.setBackground(esp.getBg())
        source.setFont(esp.getFont())
        
        def fnp := palette.makeFilenamePalette()
        def filename := <custom:makeCLabel>(sourcePane,
                                            SWT.getLEFT() | SWT.getSHADOW_OUT())
        filename.setForeground(fnp.getFg())
        filename.setBackground(fnp.getBg())
        filename.setFont(fnp.getFont())
        
        sideToSideSash.setWeights([30, 70])
        
        # strip crs
        source.addVerifyListener(def verifyListener {
            to verifyText(event) :void {
                event.setText(event.getText().canonical())
            }
        })
        
        def &everDirty := makeLamportSlot(false)
        source.addExtendedModifyListener(def eml {
            to modifyText(_) :void { everDirty := true }
        })
        
        def &everWordWrap := makeLamportSlot(true)
        whenever([&everWordWrap], fn{
            source.setWordWrap(everWordWrap)
        }, fn{
            ! source.isDisposed()
        })
        
        source.setEditable(false)
        
        /**
         * Returns either a java.io.File or a java.net.URL
         */
        def getFile(pathname) :any {
            switch (pathname) {
                match `file:@body` {
                    return <file>[body]
                }
                match `jar:@body` {
                    return <jar>[body]
                }
                match _ {
                    return <file>[pathname]
                }
            }
        }
        
        def getLine(file, first :int, fo :int, last :int, lo :int) :String {
            if (!(file.__respondsTo("exists",0)) || file.exists()) {
                def source := file.getText()
                def lines := source.split("\n")
                lines[first -1].trim()
            } else {
                `*** "${file.getPath()}" not found ***`
            }
        }
        
        def showSource(file, pathname) :void {
            filename.setText(pathname)
            source.setText(getText(file))
        }
        
        def showAndSelect(file, pathname, first, fo, last, lo) :void {
            showSource(file, pathname)
            
            # Get the number of lines.
            def lineCount := source.getLineCount()
            
            if (last + 5 < lineCount) {
                bind lineAtBottom := last + 5
            } else {
                bind lineAtBottom := lineCount
            }
            
            # Scroll the specified offset into view.
            source.setSelection(source.getOffsetAtLine(lineAtBottom -1))
            
            # Now do the real selection.
            def line1 := source.getOffsetAtLine(first -1)
            def line2 := source.getOffsetAtLine(last -1)
            source.setSelection(line1 + fo, line2 + lo +1)
        }
        
        var stackMap := [].diverge()
        
        stack.addSelectionListener(def selectionListener {
            to widgetSelected(event) :void {
                def i := stack.getSelectionIndex()
                if (i >= 0) {
                    def [pathname, [[first, fo], [last, lo]]] := stackMap[i]
                    showAndSelect(getFile(pathname), pathname, first, fo, last, lo)
                }
            }
        })
        
        def stackWalker {
            
            to open() :void {}
            
            to layout() :void {
                
                swtGrid`${stackPane}:
                    ${description}.X
                    ${stack}.X.Y`
                
                stackPane.getLayout().setMarginWidth(2)
                stackPane.getLayout().setMarginHeight(0)
                
                stackPane.getLayout().setHorizontalSpacing(0)
                stackPane.getLayout().setVerticalSpacing(2)
                
                swtGrid`${sourcePane}:
                    ${filename}.X
                    ${source}.X.Y`
                
                sourcePane.getLayout().setMarginWidth(2)
                sourcePane.getLayout().setMarginHeight(0)
                
                sourcePane.getLayout().setHorizontalSpacing(0)
                sourcePane.getLayout().setVerticalSpacing(2)
            }
            
            to showStackFrame(origin, target, frame :Stack, vatMap) :void {
                def [ov, ot] := origin
                def [tv, tt] := target
                
                def oattr := vatMap.fetchDisplayAttributes(ov)
                def tattr := vatMap.fetchDisplayAttributes(tv)
                
                description.setText(`[${oattr[0]}, $ot] causes [${tattr[0]}, $tt]`)
                
                # Remove stack entry items from list widget.
                stack.removeAll()
                
                stackMap := [].diverge()
                
                # Clear source filename label and source code text pane.
                filename.setText("")
                source.setText("")
                
                if (frame.size() > 0) {
                    for [[pathname, _], [[first, fo], [last, lo]]] in frame {
                        if (pathname != "" ) {
                            def line :String := getLine(getFile(pathname), first, fo, last, lo)
                            stack.add(line)
                            # Useful map for event handling.
                            stackMap.push([pathname, [[first, fo], [last, lo]]])
                        }
                    }
                }
                if (stack.getItemCount() > 0) {
                    stack.setSelection(0)
                    def [pathname, [[first, fo], [last, lo]]] := stackMap[0]
                    showAndSelect(getFile(pathname), pathname, first, fo, last, lo)
                }
            }
        }
    }
}

