#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def swt__uriGetter := <import:org.eclipse.swt.*>
def widget__uriGetter := <swt:widgets.*>
def custom__uriGetter := <swt:custom.*>
def layout__uriGetter := <swt:layout.*>
def SWT := <swt:makeSWT>

def makeLamportSlot := <elib:slot.makeLamportSlot>
def whenever := <elib:slot.whenever>
def EverReporter := <type:org.erights.e.elib.slot.EverReporter>

def <swttools> := <import:org.erights.e.ui.swt.*>
def swtGrid__quasiParser := <swttools:swtGridQParserMaker>()

# [[start-line, start-col], [end-line, end-col]]
def SourceSpan := Tuple[Tuple[int,int], Tuple[int, int]]

# [filename, fncname]
def SourceName := Tuple[String, String]

# A [source-name, source-span]
def StackEntry := Tuple[SourceName, nullOk[SourceSpan]]

# top-to-bottom list of stack entries
def Stack := List[StackEntry]

def getText(file) :String {
    if (!(file.__respondsTo("exists",0)) || file.exists()) {
        file.getText()
    } else {
        `*** "${file.getPath()}" not found ***`
    }
}

def stackWalkerAuthor(<file>, <jar>, makers, traceline) :near {
    
    def makeStackWalker(parent, palette, vatMap, selectionModel) :near {
        
        def sideToSideSash := <custom:makeSashForm>(parent, SWT.getHORIZONTAL())
        
        def stackPane := <widget:makeComposite>(sideToSideSash, SWT.getBORDER())
        
        def stackExplorer := <widget:makeTree>(stackPane, SWT.getSINGLE() |
                                                 (SWT.getH_SCROLL() |
                                                    SWT.getV_SCROLL()))
        
        def sp := palette.makeEStackPalette()
        stackPane.setForeground(sp.getFg())
        stackPane.setBackground(sp.getBg())
        stackPane.setFont(sp.getFont())
        stackExplorer.setForeground(sp.getFg())
        stackExplorer.setBackground(sp.getBg())
        stackExplorer.setFont(sp.getFont())
        
        def dp := palette.makeDescPalette()
        
        def description := <custom:makeCLabel>(stackPane,
                                               SWT.getCENTER() | SWT.getSHADOW_OUT())
        description.setForeground(dp.getFg())
        description.setBackground(dp.getBg())
        description.setFont(dp.getFont())
        
        def esp := palette.makeECodePalette()
        def sourcePane := <widget:makeComposite>(sideToSideSash, SWT.getBORDER())
        sourcePane.setForeground(esp.getFg())
        sourcePane.setBackground(esp.getBg())
        sourcePane.setFont(esp.getFont())
        def source := <custom:makeStyledText>(sourcePane,
                                              SWT.getH_SCROLL() | SWT.getV_SCROLL())
        source.setForeground(esp.getFg())
        source.setBackground(esp.getBg())
        source.setFont(esp.getFont())
        
        def fnp := palette.makeFilenamePalette()
        def filename := <custom:makeCLabel>(sourcePane,
                                            SWT.getLEFT() | SWT.getSHADOW_OUT())
        filename.setForeground(fnp.getFg())
        filename.setBackground(fnp.getBg())
        filename.setFont(fnp.getFont())
        
        sideToSideSash.setWeights([35, 65])
        
        # strip crs
        source.addVerifyListener(def verifyListener {
            to verifyText(event) :void {
                event.setText(event.getText().canonical())
            }
        })
        
        def &everDirty := makeLamportSlot(false)
        source.addExtendedModifyListener(def eml {
            to modifyText(_) :void { everDirty := true }
        })
        
        def &everWordWrap := makeLamportSlot(true)
        whenever([&everWordWrap], fn{
            source.setWordWrap(everWordWrap)
        }, fn{
            ! source.isDisposed()
        })
        
        source.setEditable(false)
        
        /**
         * Returns either a java.io.File or a java.net.URL
         */
        def getFile(pathname) :any {
            switch (pathname) {
                match `file:@body` {
                    return <file>[body]
                }
                match `jar:@body` {
                    return <jar>[body]
                }
                match _ {
                    return <file>[pathname]
                }
            }
        }
        
        def getOptLine(file, first :int, fo :int, last :int, lo :int) :nullOk[String] {
            if (!(file.__respondsTo("exists",0)) || file.exists()) {
                def source := file.getText()
                def lines := source.split("\n")
                if (first <= lines.size()) {
                    return lines[first -1].trim()
                }
            }
            return null
        }
        
        def getLine(file, first :int, fo :int, last :int, lo :int) :String {
            if (getOptLine(file, first, fo, last, lo) =~ result :notNull) {
                return result
            } else {
                return `*** "${file.getPath()}" not found ***`
            }
        }
        
        def getOptMessage(se :StackEntry) :nullOk[String] {
            if (se =~ [[pathname, _], [[first, fo], [last, lo]]]) {
                if (pathname != "" ) {
                    def optResult := getOptLine(getFile(pathname), first, fo, last, lo)
                    if (null != optResult) {
                        return optResult
                    }
                }
            }
            if (se =~ [[pathname, topFnc], _]) {
                if (pathname != "" && topFnc != "") {
                    def lastSlash := pathname.lastStartOf("/");
                    if (lastSlash >= 0) {
                        def lastPart := pathname(lastSlash+1)
                        if (lastPart =~ `@base.@_`) {
                            return `$base#$topFnc`
                        } else {
                            return `$lastPart#$topFnc`
                        }
                    } else {
                        return topFnc
                    }
                }
            }
            return null
        }
        
        
        def showAndSelect(file, pathname, first, fo, last, lo) :void {
            filename.setText(`$pathname  line: $first`)
            source.setText(getText(file))
            
            # Get the number of lines.
            def lineCount := source.getLineCount()
            
            def lineAtBottom
            if (last + 5 < lineCount) {
                bind lineAtBottom := last + 5
            } else {
                bind lineAtBottom := lineCount
            }
            
            # Scroll the specified offset into view.
            source.setSelection(source.getOffsetAtLine(lineAtBottom -1))
            
            # Now do the real selection.
            if (first <= lineCount && last <= lineCount) {
                def line1 := source.getOffsetAtLine(first -1)
                def line2 := source.getOffsetAtLine(last -1)
                source.setSelection(line1 + fo, line2 + lo +1)
            }
        }
        
        # Useful map for lookup in event handling.
        var itemToModelMap := [].asMap().diverge()
        
        def buildTreeItem(parent, se :StackEntry) :near {
            if (getOptMessage(se) =~ message :notNull) {
                def item := <widget:makeTreeItem>(parent, 0)
                var se2 := se
                if (se[1] == null) {
                    se2 := [se[0], [[1,0],[1,0]]]
                }
                itemToModelMap.put(item, se2, true)
                item.setText(message)
                return item
            }
            return null
        }
        
        def buildSubTree(parent, entries :Stack) :void {
            for i in 0 ..! entries.size() {
                
                def item := buildTreeItem(parent, entries[i])
                
                if (null != item) {
                    
                    for j in i +1 ..! entries.size() {
                        
                        buildTreeItem(item, entries[j])
                    }
                    return
                }
            }
        }
        
        def showStackFrame(edge) :void {
            def [ov, ot] := edge.getOrigin().getID()
            def [tv, tt] := edge.getTarget().getID()
            
            def oattr := vatMap.fetchDisplayAttributes(ov)
            def tattr := vatMap.fetchDisplayAttributes(tv)
            
            description.setText(`[${oattr[0]}, $ot] causes [${tattr[0]}, $tt]`)
            
            # Remove stack entry items from tree widget.
            stackExplorer.removeAll()
            
            itemToModelMap := [].asMap().diverge()
            
            # Clear source filename label and source code text pane.
            filename.setText("")
            source.setText("")
            
            var curEdge := edge
            while (null != curEdge) {
                def [_, entries] := curEdge.getContext()
                
                buildSubTree(stackExplorer, entries)
                
                def origin := curEdge.getOrigin()
                if (origin.getIncomingCount() == 1) {
                    curEdge := origin.getPrevIn()
                } else {
                    curEdge := null
                }
            }
            if (stackExplorer.getItemCount() > 0) {
                
                def items := stackExplorer.getItems()
                
                stackExplorer.setSelection([items[0]])
                stackExplorer.showItem(items[0])
                
                def [[pathname, _], [[first, fo], [last, lo]]] :=
                  itemToModelMap.fetch(items[0], fn{})
                showAndSelect(getFile(pathname), pathname, first, fo, last, lo)
            }
        }
        
        def selectionObserver {
            to edgeSelected(optEdge) :void {
                if (optEdge != null) {
                    showStackFrame(optEdge)
                }
            }
        }
        selectionModel.addObserver(selectionObserver)
        
        def selectionListener {
            to widgetSelected(event) :void {
                def item := event.getItem()
                if (itemToModelMap.fetch(item, fn{}) =~
                      [[pathname, _], [[first, fo], [last, lo]]]) {
                    
                    showAndSelect(getFile(pathname), pathname, first, fo, last, lo)
                }
            }
            to widgetDefaultSelected(event) :void {}
        }
        stackExplorer.addSelectionListener(selectionListener)
        
        def stackWalker {
            
            to open() :void {}
            
            to layout() :void {
                
                swtGrid`${stackPane}:
                    ${description}.X
                    ${stackExplorer}.X.Y`
                
                stackPane.getLayout().setMarginWidth(2)
                stackPane.getLayout().setMarginHeight(0)
                
                stackPane.getLayout().setHorizontalSpacing(0)
                stackPane.getLayout().setVerticalSpacing(2)
                
                swtGrid`${sourcePane}:
                    ${filename}.X
                    ${source}.X.Y`
                
                sourcePane.getLayout().setMarginWidth(2)
                sourcePane.getLayout().setMarginHeight(0)
                
                sourcePane.getLayout().setHorizontalSpacing(0)
                sourcePane.getLayout().setVerticalSpacing(2)
            }
            
            to getOptSourceLine(stackEntry :StackEntry) :nullOk[String] {
                return getOptMessage(stackEntry)
            }
        }
    }
}

