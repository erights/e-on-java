#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2008 Teleometry Design under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def swt__uriGetter := <import:org.eclipse.swt.*>
def widget__uriGetter := <swt:widgets.*>
def custom__uriGetter := <swt:custom.*>
def layout__uriGetter := <swt:layout.*>
def SWT := <swt:makeSWT>

def makeLamportSlot := <elib:slot.makeLamportSlot>
def whenever := <elib:slot.whenever>
def EverReporter := <type:org.erights.e.elib.slot.EverReporter>

def <swttools> := <import:org.erights.e.ui.swt.*>
def swtGrid__quasiParser := <swttools:swtGridQParserMaker>()

def makeOutlineView := <import:org.erights.e.tools.causeway.makeOutlineView>
def makeTextView := <import:org.erights.e.tools.causeway.makeTextView>

# [[start-line, start-col], [end-line, end-col]]
def SourceSpan := Tuple[Tuple[int,int], Tuple[int, int]]

# [filename, fncname]
def SourceName := Tuple[String, String]

# A [source-name, source-span]
def StackEntry := Tuple[SourceName, nullOk[SourceSpan]]

# top-to-bottom list of stack entries
def Stack := List[StackEntry]

def getText(file) :String {
    if (!(file.__respondsTo("exists",0)) || file.exists()) {
        file.getText()
    } else {
        `*** "${file.getPath()}" not found ***`
    }
}

def stackWalkerAuthor(<file>, <jar>, makers, traceline) :near {
    
    /**
     * Returns either a java.io.File or a java.net.URL
     */
    def getFile(pathname) :any {
        switch (pathname) {
            match `file:@body` {
                return <file>[body]
            }
            match `jar:@body` {
                return <jar>[body]
            }
            match _ {
                return <file>[pathname]
            }
        }
    }
    
    def getOptLine(file,
                   first :int,
                   fo :int,
                   last :int,
                   lo :int) :nullOk[String] {
        if (!(file.__respondsTo("exists",0)) || file.exists()) {
            def source := file.getText()
            def lines := source.split("\n")
            if (first <= lines.size()) {
                return lines[first -1].trim()
            }
        }
        return null
    }
    
    def getLine(file, first :int, fo :int, last :int, lo :int) :String {
        if (getOptLine(file, first, fo, last, lo) =~ result :notNull) {
            return result
        } else {
            return `*** "${file.getPath()}" not found ***`
        }
    }
    
    def getOptMessage(se :StackEntry, hasGot :boolean) :nullOk[String] {
        if (se =~ [[pathname, _], [[first, fo], [last, lo]]]) {
            if (pathname != "" ) {
                def optResult := getOptLine(getFile(pathname),
                                            first,
                                            fo,
                                            last,
                                            lo)
                if (null != optResult) {
                    if (hasGot) {
                        return optResult
                    } else {
                        #return `[] $optResult`
                        return optResult
                    }
                }
            }
        }
        if (se =~ [[pathname, topFnc], _]) {
            if (pathname != "" && topFnc != "") {
                def lastSlash := pathname.lastStartOf("/");
                if (lastSlash >= 0) {
                    def lastPart := pathname(lastSlash+1)
                    if (lastPart =~ `@base.@_`) {
                        return `$base#$topFnc`
                    } else {
                        return `$lastPart#$topFnc`
                    }
                } else {
                    return topFnc
                }
            }
        }
        return null
    }
    
    def makeStackWalker(swtParent, palette,
                        abstractAction,
                        selectionModel, vatMap) :near {
        
        
        def swtStackWalkerView := <widget:makeComposite>(swtParent, 0)
        
        def swtSideToSide := <custom:makeSashForm>(swtStackWalkerView,
                                                   SWT.getHORIZONTAL())
        
        def swtStackPane := <widget:makeComposite>(swtSideToSide,
                                                   SWT.getBORDER())
        
        def swtStackExplorer := <widget:makeTree>(swtStackPane,
                                                  SWT.getSINGLE() |
                                                    (SWT.getH_SCROLL() |
                                                       SWT.getV_SCROLL()))
        
        def swtDescription := <custom:makeCLabel>(swtStackPane,
                                                  SWT.getCENTER() |
                                                    SWT.getSHADOW_OUT())
        
        def getOutlineActionTargets
        def outlineView := makeOutlineView(swtStackPane, palette,
                                           abstractAction, getOutlineActionTargets)
        
        def swtSourcePane := <widget:makeComposite>(swtSideToSide,
                                                    SWT.getBORDER())
        
        def swtSourceCode := <custom:makeStyledText>(swtSourcePane,
                                                     SWT.getH_SCROLL() |
                                                       SWT.getV_SCROLL())
        
        def swtFilename := <custom:makeCLabel>(swtSourcePane,
                                               SWT.getLEFT() |
                                                 SWT.getSHADOW_OUT())
        
        def getTextActionTargets
        def textView := makeTextView(swtSourcePane, palette,
                                     abstractAction, getTextActionTargets)
        
        swtSideToSide.setWeights([35, 65])
        
        # strip crs
        swtSourceCode.addVerifyListener(def verifyListener {
            to verifyText(event) :void {
                event.setText(event.getText().canonical())
            }
        })
        
        def &everDirty := makeLamportSlot(false)
        swtSourceCode.addExtendedModifyListener(def eml {
            to modifyText(_) :void { everDirty := true }
        })
        
        def &everWordWrap := makeLamportSlot(true)
        whenever([&everWordWrap], fn{
            swtSourceCode.setWordWrap(everWordWrap)
        }, fn{
            ! swtSourceCode.isDisposed()
        })
        
        swtSourceCode.setEditable(false)
        
        def showAndSelect(file, pathname, first, fo, last, lo) :void {
            swtFilename.setText(`$pathname  line: $first`)
            swtSourceCode.setText(getText(file))
            
            # Get the number of lines.
            def lineCount := swtSourceCode.getLineCount()
            
            def lineAtBottom
            if (last + 5 < lineCount) {
                bind lineAtBottom := last + 5
            } else {
                bind lineAtBottom := lineCount
            }
            
            # Scroll the specified offset into view.
            swtSourceCode.setSelection(swtSourceCode.getOffsetAtLine(lineAtBottom -1))
            
            # Now do the real selection.
            if (first <= lineCount && last <= lineCount) {
                def line1 := swtSourceCode.getOffsetAtLine(first -1)
                def line2 := swtSourceCode.getOffsetAtLine(last -1)
                swtSourceCode.setSelection(line1 + fo, line2 + lo +1)
            }
        }
        
        # Useful map for lookup in event handling.
        var itemToModelMap := [].asMap().diverge()
        
        def buildTreeItem(swtParent,
                          se :StackEntry,
                          hasGot :boolean,
                          optText :nullOk[String]) :near {
            if (getOptMessage(se, hasGot) =~ message :notNull) {
                def swtItem := <widget:makeTreeItem>(swtParent, 0)
                var se2 := se
                if (se[1] == null) {
                    se2 := [se[0], [[1,0],[1,0]]]
                }
                itemToModelMap.put(swtItem, se2, true)
                if (null != optText) {
                    swtItem.setText(optText)
                } else {
                    swtItem.setText(message)
                }
                return swtItem
            }
            return null
        }
        
        def buildSubTree(swtParent,
                         entries :Stack,
                         hasGot :boolean,
                         optText :nullOk[String]) :near {
            for i in 0 ..! entries.size() {
                
                # first, get top-level item
                def swtOptItem := buildTreeItem(swtParent,
                                                entries[i],
                                                hasGot,
                                                optText)
                
                if (null != swtOptItem) {
                    
                    # then, second-level item(s)
                    for j in i +1 ..! entries.size() {
                        
                        buildTreeItem(swtOptItem, entries[j], true, null)
                    }
                    return swtOptItem
                }
            }
            return null
        }
        
        def showStackFrame(edge, vatMap) :void {
            def [ov, ot] := edge.getOrigin().getID()
            def [tv, tt] := edge.getTarget().getID()
            
            # [vatDisplayName, [vatColor, colorName]]
            
            def oattr := vatMap.fetchDisplayAttributes(ov)
            def tattr := vatMap.fetchDisplayAttributes(tv)
            
            swtDescription.setText(
                `[${oattr[0]}, $ot] causes [${tattr[0]}, $tt]`)
            
            # Remove stack entry items from tree widget.
            swtStackExplorer.removeAll()
            
            itemToModelMap := [].asMap().diverge()
            
            # Clear source filename label and source code text pane.
            swtFilename.setText("")
            swtSourceCode.setText("")
            
            var curEdge := edge
            while (null != curEdge) {
                def [_, entries] := curEdge.getContext()
                
                def swtOptItem := buildSubTree(swtStackExplorer,
                                               entries,
                                               curEdge.hasGotStack(),
                                               curEdge.getOptText())
                if (null != swtOptItem) {
                    def [vat, turn] := curEdge.getTarget().getID()
                    def attr := vatMap.fetchDisplayAttributes(vat)
                    # include [vat, turn] for item at top of turn
                    swtOptItem.setText(
                        `[${attr[0]}, $turn] ${swtOptItem.getText()}`)
                    swtOptItem.setForeground(attr[1][0])
                    def nested := swtOptItem.getItems()
                    for n in nested {
                        n.setForeground(attr[1][0])
                    }
                }
                
                def origin := curEdge.getOrigin()
                if (origin.getIncomingCount() >= 1) {
                    # walk back along last edge added
                    curEdge := origin.getNextIn()
                } else {
                    curEdge := null
                }
            }
            if (swtStackExplorer.getItemCount() > 0) {
                
                def swtItems := swtStackExplorer.getItems()
                
                swtStackExplorer.setSelection([swtItems[0]])
                swtStackExplorer.showItem(swtItems[0])
                
                def [[pathname, _], [[first, fo], [last, lo]]] :=
                  itemToModelMap.fetch(swtItems[0], fn{})
                showAndSelect(getFile(pathname),
                              pathname,
                              first,
                              fo,
                              last,
                              lo)
            }
        }
        
        def selectionListener {
            to widgetSelected(event) :void {
                def item := event.getItem()
                if (itemToModelMap.fetch(item, fn{}) =~
                      [[pathname, _], [[first, fo], [last, lo]]]) {
                    
                    showAndSelect(getFile(pathname),
                                  pathname,
                                  first,
                                  fo,
                                  last,
                                  lo)
                }
            }
            to widgetDefaultSelected(event) :void {}
        }
        swtStackExplorer.addSelectionListener(selectionListener)
        
        def selectionObserver {
            to edgeSelected(optEdge) :void {
                if (optEdge != null) {
                    showStackFrame(optEdge, vatMap)
                }
            }
        }
        selectionModel.addObserver(selectionObserver)
        
        bind getOutlineActionTargets(action :String) :List {
            if (action == "doExpand" || action == "doCollapse") {
                if (swtStackExplorer.getItemCount() > 0) {
                    return [swtStackExplorer]
                } else {
                    return null
                }
            }
            if (action == "doIncreaseFontSize" ||
                  action == "doDecreaseFontSize") {
                return [swtStackExplorer, swtDescription]
            }
            return null
        }
        
        bind getTextActionTargets(action :String) :List {
            if (action == "doIncreaseFontSize" ||
                  action == "doDecreaseFontSize") {
                return [swtSourceCode, swtFilename]
            }
            return null
        }
        
        def stackWalker {
            
            to open() :void {}
            
            to layout() :void {
                
                outlineView.layout()
                
                swtGrid`${swtStackPane}:
                    ${outlineView.getTopLevelPane()}.X
                    ${swtDescription}.X
                    ${swtStackExplorer}.X.Y`
                
                palette.setMargins(
                    swtStackPane.getLayout(), 2, 0, 0, 2)
                
                textView.layout()
                
                swtGrid`${swtSourcePane}:
                    ${textView.getTopLevelPane()}.X
                    ${swtFilename}.X
                    ${swtSourceCode}.X.Y`
                
                palette.setMargins(
                    swtSourcePane.getLayout(), 2, 0, 0, 2)
                
                swtGrid`${swtStackWalkerView}:
                        ${swtSideToSide}.X.Y`
            }
            
            to getOptSourceLine(stackEntry :StackEntry,
                                hasGot :boolean) :nullOk[String] {
                return getOptMessage(stackEntry, hasGot)
            }
            
            to labelNodeItem(vatMap, node, item) :void {
                def [vatName, turn] := node.getID()
                
                # Set descriptive text to vat name and turn.
                def attr := vatMap.fetchDisplayAttributes(vatName)
                item.setForeground(attr[1][0])
                item.setText(`[${attr[0]}, $turn]`)
            }
            
            to getEdgePart(edge) :nullOk[String] {
                def optText := edge.getOptText()
                if (null != optText) { return optText }
                def [_, stack] := edge.getContext()
                if ([] != stack) {
                    return stackWalker.getOptSourceLine(stack[0],
                                                        edge.hasGotStack())
                }
                return null
            }
            
            to labelArcItem(vatMap, edge, swtItem) :void {
                def [tVatName, tTurn] := edge.getTarget().getID()
                
                # Set descriptive text to vat name and turn.
                def tAttr := vatMap.fetchDisplayAttributes(tVatName)
                swtItem.setForeground(tAttr[1][0])
                
                var msg := stackWalker.getEdgePart(edge)
                if (msg == null) {
                    msg := ""
                }
                
                if (tAttr[0] == "top") {
                    #swtItem.setText(`(top)$msg`)
                    swtItem.setText(`$msg`)
                } else if (tAttr[0] == "bottom") {
                    #swtItem.setText(`(bottom)$msg`)
                    swtItem.setText(`$msg`)
                } else {
                    swtItem.setText(`[${tAttr[0]}, $tTurn] $msg`)
                }
            }
        }
        return stackWalker
    }
    return makeStackWalker
}

