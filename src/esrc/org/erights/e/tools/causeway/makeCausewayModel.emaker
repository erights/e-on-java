#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def File := <type:java.io.File>
def makeSourceSpan := <elib:base.makeSourceSpan>
def jp := <import:org.quasiliteral.term.makeTermParser>
def <causeway> := <import:org.erights.e.tools.causeway.*>
def makeMessageGraph := <causeway:makeMessageGraph>
def makeRawGraph := <causeway:makeRawGraph>
def filterGraph := <causeway:filterGraph>


# [[start-line, start-col], [end-line, end-col]]
# [[1, 0]] is the first character in a source file.
# start-col refers to the first character of interest.
# end-col refers to the last character of interest.
def SourceSpan := Tuple[Tuple[int,int], Tuple[int, int]]

# [filename, fncname]
def SourceName := Tuple[String, String]

# A [source-name, source-span]
def StackEntry := Tuple[SourceName, nullOk[SourceSpan]]

# top-to-bottom list of stack entries
def Stack := List[StackEntry]

def VatName := String

def Turn := int
def Anchor := int

def UTurn := Tuple[VatName, Turn]

# one of "org.ref_send.log.Sent", ...
def SendingContext := String


/**
 * <tt>makeCausewayModel</tt>
 * <p>
 *
 */
def makeCausewayModel(var rootDirName :String,
                      traceFiles :List[File],
                      <file>, 
                      traceline) :near {
    def [rawGraph, rawTop] := makeRawGraph(rootDirName, 
                                           traceFiles, 
                                           <file>, 
                                           traceline)
    def [graph, top] := filterGraph(rawGraph, rawTop, traceline)

    # Map[VatName, Map[Turn, TurnNode]]
    def ordered := [].asMap().diverge()
    for node in top.deepOutsPre() {
        def [vatName, turn] := node.getID()
        if (vatName != "bottom") {
            def map := ordered.fetch(vatName, fn{[].asMap().diverge()})
            map[turn] := node
            ordered[vatName] := map
        }
    }
    for name => map in ordered {
        # each vatName is mapped to a sorted list of events
        ordered[name] := map.sortKeys()
    }
    
    def causewayModel {
        
        to getTop() :near {
            return top
        }
        
        to getVatSet() :near {
            return ordered.getKeys().snapshot()
        }
        
        # Map[VatName, List[TurnNode]]
        to getPOMap() :Map {
            def result := [].asMap().diverge()
            for vatName => map in ordered {
                result[vatName] := map.getValues().snapshot()
            }
            return result.snapshot()
        }
        
        to exportToDotFile(root, dotFile :File, 
                           palette, vatMap, graphWalker) :void {
            graph.connectTheDots(root, dotFile, palette,
                                 vatMap, graphWalker)
        }
    }
    
    return causewayModel
}
