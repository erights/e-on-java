#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def makeMessageGraph :=
  <import:org.erights.e.tools.causeway.makeMessageGraph>

def File := <type:java.io.File>

# [[start-line, start-col], [end-line, end-col]]
# [[1, 0]] is the first character in a source file.
def SourceSpan := Tuple[Tuple[int,int], Tuple[int, int]]

# [filename, fncname]
def SourceName := Tuple[String, String]

# A [source-name, source-span]
def StackEntry := Tuple[SourceName, SourceSpan]

# top-to-bottom list of stack entries
def Stack := List[StackEntry]

def VatName := String

def Turn := int

def UTurn := Tuple[VatName, Turn]

# one of "org.ref_send.log.Sent", ...
def SendingContext := String

# The root directory of the source files
# specified on Causeway command line.
def sourceCodeRootDirName

def fixupSource(source :String) :String {
    #def path := source.replaceAll(".", "/")
    return sourceCodeRootDirName + source
}

# Turn valid trace file spans into a fully-specified SourceSpan.
# [[start-line, start-col], [end-line, end-col]]
# [[1, 0]] is the first character in a source file.
# def SourceSpan := Tuple[Tuple[int,int], Tuple[int, int]]
# For example,
# [ [ 5 ] ] ==>        [ [ 5, 0 ], [ 5, 0 ] ]
# [ [ 5 ], [ 6 ] ] ==> [ [ 5, 0 ], [ 6, 0 ] ]

def spanner(span) :SourceSpan {
    def term`[ [@{sline :int},
                @{scolL :List[int]}?], 
              ([@{elineL :List[int]}, 
                @{ecolLL :List[List[int]]}?])?]` := span
    return [[sline,
             if (scolL =~ [scol]) {scol} else {0}],
            [if (elineL =~ [eline]) {eline} else {sline},
             if (ecolLL =~ [[ecol]]) {ecol} else {
        if (scolL =~ [scol]) {scol} else {0}}]]
}

def sortTree(node) :void {
    var edges := [].asMap().diverge()
    for edge => target in node.outs() {
        sortTree(target)
        edges[edge.getAnchor()] := edge
    }
    edges := edges.sortKeys()
    for edge in edges {
        edge.setOrigin(node)
    }
}

/**
 * <tt>makeCausewayModel</tt>
 * <p>
 *
 */
def makeCausewayModel(var rootDirName :String, traceFiles :List[File], <file>, traceline) :near {
    
    if (!(rootDirName.endsWith("/"))) {
        rootDirName += "/"
    }
    
    bind sourceCodeRootDirName := rootDirName
    
    # TurnTable := List[TurnNode]
    # Map[VatName, TurnTable]
    def vatMap := [].asMap().diverge()
    
    # Map[MsgID, EventArc]
    def msgMap := [].asMap().diverge()
    
    # Map[VatName, List[EventArc]]
    def ordered := [].asMap().diverge()
    
    def graph := makeMessageGraph(traceline)
    def ether := graph.makeTurnNode(["ether", 0], "ether placeholder")
    # ether does not really belong in the graph, but it's useful for debugging, for now
    graph.addTurnNode(ether)
    
    def jp := <import:org.quasiliteral.term.makeTermParser>
    
    # Parse term tree structure. Return E Stack object which could be empty.
    def parseStack(stack) :Stack {
        def entries := [].diverge()
        entries.ensureSize(stack.size())
        
        for i in 0 ..! stack.size() {
            
            switch (stack[i]) {
                match term`{ "name" : @{fnc :String},
                             "source" : @{source :String},
                             "span" : @span }` {
                    entries[i] := [[fixupSource(source), fnc], spanner(span)]
                }
                
                match term`{ "name" : @{fnc :String},
                             "source" : @{source :String} }` {
                    entries[i] := [[fixupSource(source), fnc], spanner(term`[[1]]`)]
                }
            }
        }
        return entries.snapshot()
    }
    
    # Each vat has a turn table of nodes, one node for each turn.
    # Return the node for the turn in the vat.
    # If the node does not exist yet, make it.
    def getOrMakeTurnNode(name :VatName, turn :Turn) :near {
        def turns := vatMap.fetch(name, fn{[].diverge()})
        turns.ensureSize(turn+1)
        vatMap[name] := turns
        var node := turns[turn]
        if (node == null) {
            node := graph.makeTurnNode([name, turn], "")
            graph.addTurnNode(node)
            turns[turn] := node
        }
        return node
    }
    
    # Add the edge to the process-order list.
    # Sent anchor numbers define order.
    def storeEdge(edge) :void {
        def [vatName, turn] := edge.getOrigin().getID()
        def anchorPair := [turn, edge.getAnchor()]
        def poMap := ordered.fetch(vatName, fn{[].asMap().diverge()})
        ordered[vatName] := poMap
        poMap[anchorPair] := edge
    }
    
    for tfile in traceFiles {
        
        #traceline(`tracefile: $tfile`)
        
        def t := tfile.getText()
        def tt := jp(t)
        
        tt =~ term`[@chunks*]`
        
        for chunk in chunks {
            switch (chunk) {
                
                match term`{ "$$" : [ "org.ref_send.log.Sent",
                                      "org.ref_send.log.Event" ],
                             "anchor" : {
                                 "number" : @{anchor :int},
                                 "turn" : {
                                     "loop" : @{name :String},
                                     "number" : @{turn :int}
                                 }
                             },
                             "message" : @{message :String},
                             "trace" : { "calls" : [@stack*] }
                           }` {
                    
                    def origin := getOrMakeTurnNode(name, turn)
                    
                    # Create E Stack object, possibly empty, from term tree.
                    def entries := parseStack(stack)
                    
                    var edge := msgMap.fetch(message, fn{null})
                    if (edge == null) {
                        
                        # Sent seen first. Make the edge and put it in the msgMap.
                        # The corresponding Got will fetch the edge from the msgMap.
                        # The anchor number for an edge is set by the Sent.
                        
                        edge := graph.makeEventArc(origin, ether,
                                                   ["org.ref_send.log.Sent",
                                                    entries])
                        edge.setAnchor(anchor)
                        edge.addLogFile(tfile)
                        msgMap[message] := edge
                        
                    } else {
                        
                        # Got (or something) seen first. Fetch the edge from the msgMap.
                        # Replace place-holder ether object with origin.
                        # Update context object with stack trace.
                        
                        if (edge.getOrigin() == ether) {
                            edge.setOrigin(origin)
                            edge.setContext(["org.ref_send.log.Sent",
                                             entries])
                            edge.setAnchor(anchor)
                            edge.addLogFile(tfile)
                            if (entries =~ [[[_, topFnc], _]]+_) {
                                if (topFnc != "") {
                                    # For now, this function name is useful.
                                    # Comments or descriptive messages would be better.
                                    edge.setMessage(topFnc)
                                }
                            }
                            
                            # Add the edge to the process-order list.
                            storeEdge(edge)
                            
                        } else { traceline(`origin conflict`) }
                    }
                }
                match term`{ "$$" : [ "org.ref_send.log.SentIf",
                                      "org.ref_send.log.Sent",
                                      "org.ref_send.log.Event" ],
                             "anchor" : {
                                 "number" : @{anchor :int},
                                 "turn" : {
                                     "loop" : @{name :String},
                                     "number" : @{turn :int}
                                 }
                             },
                             "condition" : @{condition :String},
                             "message" : @{message :String},
                             "trace" : { "calls" : [@stack*] }
                           }` {
                    
                    def origin := getOrMakeTurnNode(name, turn)
                    
                    # Create E Stack object, possibly empty, from term tree.
                    def entries := parseStack(stack)
                    
                    var edge := msgMap.fetch(message, fn{null})
                    if (edge == null) {
                        
                        # SentIf seen first. Make the edge and put it in the msgMap.
                        # The corresponding Got will fetch the edge from the msgMap.
                        # The anchor number for an edge is set by the SentIf.
                        
                        edge := graph.makeEventArc(origin, ether,
                                                   ["org.ref_send.log.SentIf",
                                                    entries])
                        edge.setAnchor(anchor)
                        edge.addLogFile(tfile)
                        msgMap[message] := edge
                        
                    } else {
                        
                        # Got (or something) seen first. Fetch the edge from the msgMap.
                        # Replace place-holder ether object with origin.
                        # Update context object with stack trace.
                        
                        if (edge.getOrigin() == ether) {
                            edge.setOrigin(origin)
                            edge.setContext(["org.ref_send.log.SentIf",
                                             entries])
                            edge.setAnchor(anchor)
                            edge.addLogFile(tfile)
                            if (entries =~ [[[_, topFnc], _]]+_) {
                                if (topFnc != "") {
                                    # For now, this function name is useful.
                                    # Comments or descriptive messages would be better.
                                    edge.setMessage(topFnc)
                                }
                            }
                            
                            # Add the edge to the process-order list.
                            storeEdge(edge)
                            
                        } else { traceline(`origin conflict`) }
                    }
                }
                match term`{ "$$" : [ "org.ref_send.log.Got",
                                      "org.ref_send.log.Event" ],
                             "anchor" : {
                                 "number" : @{anchor :int},
                                 "turn" : {
                                     "loop" : @{name :String},
                                     "number" : @{turn :int}
                                 }
                             },
                             "message" : @{message :String},
                             "trace" : { "calls" : [@stack*] }
                           }` {
                    
                    def target := getOrMakeTurnNode(name, turn)
                    
                    var edge := msgMap.fetch(message, fn{null})
                    if (edge == null) {
                        
                        # Got seen first. Make the edge and put it in the msgMap.
                        # The corresponding Sent will fetch the edge from the msgMap.
                        
                        edge := graph.makeEventArc(ether, target,
                                                   ["org.ref_send.log.Got", []])
                        edge.addLogFile(tfile)
                        msgMap[message] := edge
                        
                    } else {
                        
                        # Sent (or something) seen first. Fetch the edge from the msgMap.
                        # Replace place-holder ether object with target.
                        
                        if (edge.getTarget() == ether) {
                            edge.setTarget(target)
                            edge.addLogFile(tfile)
                            
                            def [_, entries] := edge.getContext()
                            if (entries =~ [[[_, topFnc], _]]+_) {
                                if (topFnc != "") {
                                    # For now, this function name is useful.
                                    # Comments or descriptive messages would be better.
                                    edge.setMessage(topFnc)
                                }
                            }
                            
                            # Add the edge to the process-order list.
                            # Sent anchor numbers define order.
                            storeEdge(edge)
                            
                        } else { traceline(`target conflict`) }
                    }
                }
                
                match term`{ "$$" : [ "org.ref_send.log.Comment",
                                      "org.ref_send.log.Event" ],
                             "anchor" : {
                                 "number" : @{anchor :int},
                                 "turn" : {
                                     "loop" : @{name :String},
                                     "number" : @{turn :int}
                                 }
                             },
                             "text" : @{comment :String},
                             "trace" : { "calls" : [@stack*] }
                           }` {
                    
                    def origin := getOrMakeTurnNode(name, turn)
                    
                    # Create E Stack object, possibly empty, from term tree.
                    def entries := parseStack(stack)
                    
                    def edge := graph.makeEventArc(origin, ether,
                                                   ["org.ref_send.log.Comment",
                                                    entries])
                    edge.setAnchor(anchor)
                    edge.addLogFile(tfile)
                    
                    var omsg := "# " + comment
                    if (entries =~ [[[_, topFnc], _]]+_) {
                        if (topFnc != "") {
                            omsg := topFnc + "    " + omsg
                        }
                    }
                    edge.setMessage(omsg)
                    
                    # Add the edge to the process-order list.
                    storeEdge(edge)
                }
                match _ {}
            }
        }
    }
    
    for name => poMap in ordered {
        ordered[name] := poMap.sortKeys()
    }
    
    def sz := graph.getSize()
    #traceline(`graph size: $sz`)
    def roots := graph.getRoots()
    def root
    if (roots.size() == 1) {
        bind root := roots[0]
    } else {
        bind root := graph.makeTurnNode(["top", 0], "top")
        graph.addTurnNode(root)
        for r in roots {
            graph.makeEventArc(root, r, ["", []])
        }
    }
    #graph.walkRelations(root, 0, traceline)
    
    sortTree(root)
    
    def causewayModel {
        
        to getTop() :near {
            return root
        }
        
        to getVatSet() :near {
            return vatMap.getKeys().snapshot()
        }
        
        to getOrdered(vatName :String) :List {
            def poMap := ordered.fetch(vatName, fn{[].asMap()})
            return poMap.getValues()
        }
    }
    
    return causewayModel
}


