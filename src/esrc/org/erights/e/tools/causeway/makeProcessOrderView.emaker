#!/usr/bin/env rune

pragma.syntax("0.9")

# Copyright 2008 Teleometry Design under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def swt__uriGetter := <import:org.eclipse.swt.*>
def widget__uriGetter := <swt:widgets.*>
def custom__uriGetter := <swt:custom.*>
def SWT := <swt:makeSWT>

def <swttools> := <import:org.erights.e.ui.swt.*>
def swtGrid__quasiParser := <swttools:swtGridQParserMaker>()

def makeOutlineView := <import:org.erights.e.tools.causeway.makeOutlineView>

# Useful maps for lookups in event handling.
def itemToModelMap := [].asMap().diverge()
def modelToItemMap := [].asMap().diverge()

def buildTreeItem(swtParent, element, ndx, vatMap, graphWalker) :near {
    def swtItem := <widget:makeTreeItem>(swtParent, 0)
    itemToModelMap.put([swtItem, ndx], element, true)
    modelToItemMap.put(element, [swtItem, ndx], true)
    graphWalker.labelItem(vatMap, element, swtItem)
    return swtItem
}

def buildTree(swtParent, poList, ndx,
              vatMap, graphWalker) :void {
    
    for node in poList {
        def swtNodeItem := buildTreeItem(swtParent, node, 
                                         ndx, vatMap, graphWalker)
        for edge => _ in node.outs() {
            buildTreeItem(swtNodeItem, edge, ndx, vatMap, graphWalker)
        }
    }
}

def makePOPane(swtParent, poList, ndx,
               selectionModel, vatMap, graphWalker) :near {
    
    def swtPane := <widget:makeComposite>(swtParent, 0)
    def swtTree := <widget:makeTree>(swtPane,
                                     SWT.getSINGLE() |
                                       (SWT.getH_SCROLL() | SWT.getV_SCROLL()))
    
    buildTree(swtTree, poList, ndx, vatMap, graphWalker)
    
    def swtSelectionListener {
        to widgetSelected(swtEvent) :void {
            def swtItem := swtEvent.getItem()
            def element := itemToModelMap.fetch([swtItem, ndx], fn{})
            selectionModel.setOptElement(element)
        }
        to widgetDefaultSelected(swtEvent) :void {}
    }
    swtTree.addSelectionListener(swtSelectionListener)
    
    def pop {
        
        to getPane() :near { return swtPane }
        
        to getWidget() :near { return swtTree }
        
        to activate() :void {}
        
        to layout() :void {
            
            swtGrid`${swtPane}:
                    ${swtTree}.X.Y`
            
            swtPane.getLayout().setMarginWidth(0)
            swtPane.getLayout().setMarginHeight(0)
            swtPane.getLayout().setHorizontalSpacing(0)
            swtPane.getLayout().setVerticalSpacing(0)
        }
    }
    return pop
}

def makeProcessOrderView(swtParent, palette,
                         abstractAction,
                         poModel, selectionModel,
                         vatMap, graphWalker) :near {
    
    def swtPOView := <widget:makeComposite>(swtParent, 0)
    
    def getActionTargets
    def outlineView := makeOutlineView(swtPOView, palette,
                                       abstractAction, getActionTargets)
    
    def swtFolder := <widget:makeTabFolder>(swtPOView, 0)
    
    def tabKeeper := [].diverge()
    
    # Map [VatName, List[TurnNode]]
    for vatName => poList in poModel {
        
        def swtTab := <widget:makeTabItem>(swtFolder, 0)
        
        def pop := makePOPane(swtFolder,
                              poList, swtFolder.indexOf(swtTab),
                              selectionModel, vatMap, graphWalker)
        
        swtTab.setControl(pop.getPane())
        swtTab.setText(vatMap.fetchDisplayAttributes(vatName)[0])
        tabKeeper[swtFolder.indexOf(swtTab)] := [swtTab, pop]
    }
    
    def selectionObserver {
        to elementSelected(optElement) :void {
            def tabbedItem := modelToItemMap.fetch(optElement, fn{})
            if (tabbedItem != null) {
                def [swtItem, ndx] := tabbedItem
                swtFolder.setSelection(ndx)
                def [_, pop] := tabKeeper[ndx]
                pop.getWidget().setSelection([swtItem])
                pop.getWidget().showItem(swtItem)
            }
        }
    }
    selectionModel.addObserver(selectionObserver)
    
    def getCurrentTree() :near {
        def ndx := swtFolder.getSelectionIndex()
        if (ndx != -1) {
            def [_, pop] := tabKeeper[ndx]
            return pop.getWidget()
        }
        return null
    }
    
    bind getActionTargets(_ :String) :List {
        def swtTree := getCurrentTree()
        if (null != swtTree) {
            return [swtTree]
        }
        return null
    }
    
    def pov {
        
        to open() :void {}
        
        to layout() :void {
            
            outlineView.layout()
            
            for [_, pop] in tabKeeper {
                pop.layout()
            }
            swtGrid`${swtPOView}:
                    ${outlineView.getTopLevelPane()}.X
                    ${swtFolder}.X.Y`
        }
    }
    return pov
}
