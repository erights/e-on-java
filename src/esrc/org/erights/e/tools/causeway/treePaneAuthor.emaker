#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2008 Teleometry Design under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def swt__uriGetter := <import:org.eclipse.swt.*>
def widget__uriGetter := <swt:widgets.*>
def custom__uriGetter := <swt:custom.*>
def SWT := <swt:makeSWT>

def <swttools> := <import:org.erights.e.ui.swt.*>
def swtGrid__quasiParser := <swttools:swtGridQParserMaker>()

def makeOTMap() :near {
    def map := [].asMap().diverge()
    
    def otMap {
        
        to see(o, t) :void {
            map[[o, t]] := [o, t]
        }
        
        to hasSeen(o, t) :boolean {
            if (map.fetch([o, t], fn{}) == null) {
                return false
            } else {
                return true
            }
        }
    }
    return otMap
}

# Useful maps for lookups in event handling.
def itemToModelMap := [].asMap().diverge()
def modelToItemMap := [].asMap().diverge()

def buildTree(parent, palette, edge, vatMap, otMap, stackWalker, traceline) :void {
    
    if (otMap.hasSeen(edge.getOrigin(), edge.getTarget())) {
        return;
    }
    otMap.see(edge.getOrigin(), edge.getTarget())
    
    def item := <widget:makeTreeItem>(parent, 0)
    
    itemToModelMap.put(item, edge, true)
    modelToItemMap.put(edge, item, true)
    
    stackWalker.labelArcItem(vatMap, edge, item)
    
    for ge => _ in edge.getTarget().outs() {
        buildTree(item, palette, ge, vatMap, otMap, stackWalker, traceline)
    }
}

def treePaneAuthor(traceline) :near {
    
    def makeTreePane(parent, palette, vatMap,
                     graph, selectionModel, stackWalker) :near {
        
        def pane := <widget:makeComposite>(parent, 0)
        def tree := <widget:makeTree>(pane,
                                      SWT.getSINGLE() |
                                        (SWT.getH_SCROLL() | SWT.getV_SCROLL()))
        
        def mtp := palette.makeMessageTreePalette()
        tree.setForeground(mtp.getFg())
        tree.setBackground(mtp.getBg())
        tree.setFont(mtp.getFont())
        
        def otMap := makeOTMap()
        for  edge => _ in graph.outs() {
            #traceline(`buildTree (top level) o: ${edge.getOrigin()} t: ${edge.getTarget()}`)
            buildTree(tree, mtp, edge, vatMap, otMap, stackWalker, traceline)
        }
        
        def selectionObserver {
            to edgeSelected(optEdge) :void {
                def item := modelToItemMap.fetch(optEdge, fn{})
                if (item != null) {
                    tree.setSelection([item])
                    tree.showItem(item)
                } else {
                    tree.deselectAll()
                }
            }
        }
        selectionModel.addObserver(selectionObserver)
        
        def selectionListener {
            to widgetSelected(event) :void {
                def item := event.getItem()
                def edge := itemToModelMap.fetch(item, fn{})
                selectionModel.setOptEdge(edge)
            }
            to widgetDefaultSelected(event) :void {}
        }
        tree.addSelectionListener(selectionListener)
        
        def treePane {
            
            to getPane() :near { return pane }
            
            to getWidget() :near { return tree }
            
            to activate() :void {}
            
            to layout() :void {
                
                swtGrid`${pane}:
                        ${tree}.X.Y`
                
                pane.getLayout().setMarginWidth(0)
                pane.getLayout().setMarginHeight(0)
                pane.getLayout().setHorizontalSpacing(0)
                pane.getLayout().setVerticalSpacing(0)
            }
            
            to getTabLabel() :String { return "Message Tree" }
        }
        return treePane
    }
}
