#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def swt__uriGetter := <import:org.eclipse.swt.*>
def widget__uriGetter := <swt:widgets.*>
def custom__uriGetter := <swt:custom.*>
def SWT := <swt:makeSWT>

def <swttools> := <import:org.erights.e.ui.swt.*>
def swtGrid__quasiParser := <swttools:swtGridQParserMaker>()

def makeOTMap() :near {
    def map := [].asMap().diverge()
    
    def otMap {
        
        to see(o, t) :void {
            map[[o, t]] := [o, t]
        }
        
        to hasSeen(o, t) :boolean {
            if (map.fetch([o, t], fn{}) == null) {
                return false
            } else {
                return true
            }
        }
    }
    return otMap
}

# Useful maps for lookups in event handling.
def itemToModelMap := [].asMap().diverge()
def modelToItemMap := [].asMap().diverge()

def labelNodeItem(vatMap, node, item) :void {
    def [vatName, turn] := node.getID()
    
    # Set descriptive text to vat name and turn.
    def attr := vatMap.fetchDisplayAttributes(vatName)
    item.setForeground(attr[1])
    item.setText(`[${attr[0]}, $turn]`)
}

def getEdgePart(edge) :String {
    def [sc, _] := edge.getContext()
    # find most specific sending context event type
    if (sc != "") {
        def parts := sc.split(".")
        if (parts.size() >= 1) {
            def part := parts.last()
            switch (part) {
                match `Sent` { return " ->" }
                match `SentIf` { return " ..." }
                match `Comment` { return "" }
                match _ { return ` ($part)` }
            }
        }
    }
    return ":"
}

def labelArcItem(vatMap, edge, item) :void {
    def [tVatName, tTurn] := edge.getTarget().getID()
    
    # Set descriptive text to vat name and turn.
    def tAttr := vatMap.fetchDisplayAttributes(tVatName)
    item.setForeground(tAttr[1])
    def part := getEdgePart(edge)
    def msg := edge.getMessage()
    if (tAttr[0] == "ether") {
        item.setText(`$msg$part`)
    } else {
        item.setText(`$msg$part [${tAttr[0]}, $tTurn]`)
    }
}

def buildTree(parent, palette, edge, vatMap, otMap, traceline) :void {
    
    #traceline(`buildTree o: ${edge.getOrigin()} t: ${edge.getTarget()}`)
    
    #if (otMap.hasSeen(edge.getOrigin(), edge.getTarget())) {
    #return;
    #}
    #otMap.see(edge.getOrigin(), edge.getTarget())
    
    def item := <widget:makeTreeItem>(parent, 0)
    
    itemToModelMap.put(item, edge, true)
    modelToItemMap.put(edge, item, true)
    
    labelArcItem(vatMap, edge, item)
    
    for ge => _ in edge.getTarget().outs() {
        buildTree(item, palette, ge, vatMap, otMap, traceline)
    }
}

def treePaneAuthor(traceline) :near {
    
    def makeTreePane(parent, palette, graph, vatMap, stackWalker, debugPane) :near {
        
        def pane := <widget:makeComposite>(parent, 0)
        def tree := <widget:makeTree>(pane,
                                      SWT.getSINGLE() |
                                        (SWT.getH_SCROLL() | SWT.getV_SCROLL()))
        
        def mtp := palette.makeMessageTreePalette()
        tree.setForeground(mtp.getFg())
        tree.setBackground(mtp.getBg())
        tree.setFont(mtp.getFont())
        
        for  edge => _ in graph.outs() {
            buildTree(tree, mtp, edge, vatMap, makeOTMap(), traceline)
        }
        
        def listenerForStackWalker {
            to widgetSelected(event) :void {
                def item := event.getItem()
                def edge := itemToModelMap.fetch(item, fn{})
                if (edge != null) {
                    def [_, stack] := edge.getContext()
                    stackWalker.showStackFrame(edge.getOrigin().getID(),
                                               edge.getTarget().getID(),
                                               stack, vatMap)
                }
            }
            to widgetDefaultSelected(event) :void {}
        }
        
        tree.addSelectionListener(listenerForStackWalker)
        
        def listenerForDebugPane {
            to widgetSelected(event) :void {
                def item := event.getItem()
                def edge := itemToModelMap.fetch(item, fn{})
                if (edge != null) {
                    debugPane.showLogFiles(edge.getLogFiles())
                }
            }
            to widgetDefaultSelected(event) :void {}
        }
        
        tree.addSelectionListener(listenerForDebugPane)
        
        def treePane {
            
            to getPane() :near { return pane }
            
            to getWidget() :near { return tree }
            
            to selectAndShow(item) :void {
                # swt requires an array even for single selection
                def selection := [].diverge()
                selection.push(item)
                tree.setSelection(selection.snapshot())
                tree.showItem(item)
            }
            
            to deselect() :void {
                if (tree.getSelectionCount() > 0) {
                    tree.deselectAll()
                }
            }
            
            to syncSelect(selection) :void {
                def item := modelToItemMap.fetch(selection, fn{})
                if (item != null) {
                    treePane.selectAndShow(item)
                } else {
                    treePane.deselect()
                }
            }
            
            to activate() :void {}
            
            to layout() :void {
                
                swtGrid`${pane}:
                        ${tree}.X.Y`
                
                pane.getLayout().setMarginWidth(0)
                pane.getLayout().setMarginHeight(0)
                pane.getLayout().setHorizontalSpacing(0)
                pane.getLayout().setVerticalSpacing(0)
            }
            
            to getTabLabel() :String { return "Message Tree" }
        }
        return treePane
    }
}
