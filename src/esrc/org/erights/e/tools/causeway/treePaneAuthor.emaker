#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def swt__uriGetter := <import:org.eclipse.swt.*>
def widget__uriGetter := <swt:widgets.*>
def custom__uriGetter := <swt:custom.*>
def SWT := <swt:makeSWT>

def <swttools> := <import:org.erights.e.ui.swt.*>
def swtGrid__quasiParser := <swttools:swtGridQParserMaker>()

def makeOTMap() :near {
    def map := [].asMap().diverge()
    
    def otMap {
        
        to see(o, t) :void {
            map[[o, t]] := [o, t]
        }
        
        to hasSeen(o, t) :boolean {
            if (map.fetch([o, t], fn{}) == null) {
                return false
            } else {
                return true
            }
        }
    }
    return otMap
}

# Useful maps for lookups in event handling.
def itemToModelMap := [].asMap().diverge()
def modelToItemMap := [].asMap().diverge()

def labelNodeItem(vatMap, node, item) :void {
    def [vatName, turn] := node.getID()
    
    # Set descriptive text to vat name and turn.
    def attr := vatMap.fetchDisplayAttributes(vatName)
    item.setForeground(attr[1])
    item.setText(`[${attr[0]}, $turn]`)
}

def getEdgePart(edge, stackWalker) :nullOk[String] {
    def [_, stack] := edge.getContext()
    if ([] != stack) {
        return stackWalker.getOptSourceLine(stack[0])
    }
    return null
}

def labelArcItem(vatMap, edge, item, stackWalker) :void {
    def [tVatName, tTurn] := edge.getTarget().getID()
    
    # Set descriptive text to vat name and turn.
    def tAttr := vatMap.fetchDisplayAttributes(tVatName)
    item.setForeground(tAttr[1])
    
    var msg := getEdgePart(edge, stackWalker)
    if (null == msg) {
        msg := edge.getMessage()
    }
    
    if (tAttr[0] == "ether") {
        item.setText(`$msg`)
    } else {
        item.setText(`[${tAttr[0]}, $tTurn] $msg`)
    }
}

def buildTree(parent, palette, edge, vatMap, otMap, stackWalker, traceline) :void {
    
    #traceline(`buildTree o: ${edge.getOrigin()} t: ${edge.getTarget()}`)
    
    #if (otMap.hasSeen(edge.getOrigin(), edge.getTarget())) {
    #return;
    #}
    #otMap.see(edge.getOrigin(), edge.getTarget())
    
    def item := <widget:makeTreeItem>(parent, 0)
    
    itemToModelMap.put(item, edge, true)
    modelToItemMap.put(edge, item, true)
    
    labelArcItem(vatMap, edge, item, stackWalker)
    
    for ge => _ in edge.getTarget().outs() {
        buildTree(item, palette, ge, vatMap, otMap, stackWalker, traceline)
    }
}

def treePaneAuthor(traceline) :near {
    
    def makeTreePane(parent, palette, vatMap,
                     graph, selectionModel, stackWalker) :near {
        
        def pane := <widget:makeComposite>(parent, 0)
        def tree := <widget:makeTree>(pane,
                                      SWT.getSINGLE() |
                                        (SWT.getH_SCROLL() | SWT.getV_SCROLL()))
        
        def mtp := palette.makeMessageTreePalette()
        tree.setForeground(mtp.getFg())
        tree.setBackground(mtp.getBg())
        tree.setFont(mtp.getFont())
        
        for  edge => _ in graph.outs() {
            buildTree(tree, mtp, edge, vatMap, makeOTMap(), stackWalker, traceline)
        }
        
        def selectionObserver {
            to edgeSelected(optEdge) :void {
                def item := modelToItemMap.fetch(optEdge, fn{})
                if (item != null) {
                    tree.setSelection([item])
                    tree.showItem(item)
                } else {
                    tree.deselectAll()
                }
            }
        }
        selectionModel.addObserver(selectionObserver)
        
        def selectionListener {
            to widgetSelected(event) :void {
                def item := event.getItem()
                def edge := itemToModelMap.fetch(item, fn{})
                selectionModel.setOptEdge(edge)
            }
            to widgetDefaultSelected(event) :void {}
        }
        tree.addSelectionListener(selectionListener)
        
        def treePane {
            
            to getPane() :near { return pane }
            
            to getWidget() :near { return tree }
            
            to activate() :void {}
            
            to layout() :void {
                
                swtGrid`${pane}:
                        ${tree}.X.Y`
                
                pane.getLayout().setMarginWidth(0)
                pane.getLayout().setMarginHeight(0)
                pane.getLayout().setHorizontalSpacing(0)
                pane.getLayout().setVerticalSpacing(0)
            }
            
            to getTabLabel() :String { return "Message Tree" }
        }
        return treePane
    }
}
