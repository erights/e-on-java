#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def templateVertex := <elib:tables.graph.templateVertex>
def templateEdge := <elib:tables.graph.templateEdge>

def makeDirectedGraph := <elib:tables.graph.makeDirectedGraph>

# [[start-line, start-col], [end-line, end-col]]
def SourceSpan := Tuple[Tuple[int,int], Tuple[int, int]]

# [filename, fncname]
def SourceName := Tuple[String, String]

# A [source-name, source-span]
def StackEntry := Tuple[SourceName, SourceSpan]

# top-to-bottom list of stack entries
def Stack := List[StackEntry]

def VatName := String

def Turn := int

def UTurn := Tuple[VatName, Turn]

# one of "org.ref_send.log.Sent", ...
def SendingContext := String

def Message := String

def walk(edge, level, traceline) :void {
    
    def origin := edge.getOrigin()
    def target := edge.getTarget()
    
    def who := origin.getID()
    def [oname, oturn] := who
    def omsg := origin.getMessage()
    
    def toWhom := target.getID()
    def [tname, tturn] := toWhom
    def tmsg := target.getMessage()
    
    traceline(`origin [$oname:$oturn] $omsg`)
    traceline(`target [$tname:$tturn] $tmsg`)
    traceline(``)
    
    for grandEdge => _ in target.outs() {
        walk(grandEdge, level + 1, traceline)
    }
}

/**
 * <tt>makeMessageGraph</tt>
 * <p>
 *
 */
def makeMessageGraph(traceline) :near {
    
    def dag := makeDirectedGraph(traceline)
    
    def mkMessageEvent(id :UTurn, var message :Message) :near {
        var leafStack :Stack := []
        def messageEvent extends templateVertex(messageEvent, id) {
            to getMessage() :Message { message }
            to setMessage(newMessage :Message) :void { message := newMessage }
            
            to hasLeafStack() :boolean { leafStack != [] }
            
            to getLeafStack() :Stack { leafStack }
            to setLeafStack(stack :Stack) :any { leafStack := stack }
            
            to getVatName() :VatName {
                id =~ [name, _]
                return name
            }
            
            to __printOn(out :TextWriter) :void {
                out.print(id)
            }
        }
    }
    
    def mkMessageContext(origin :near,
                         target :near,
                         var context :Tuple[SendingContext, Stack]) :near {
        var why :String := ""
        var ticket :int := 0
        def messageContext extends templateEdge(messageContext,
                                                origin,
                                                target) {
            to getContext() :Tuple[SendingContext, Stack] {
                return context
            }
            to setContext(ctx :Tuple[SendingContext, Stack]) :void {
                context := ctx
            }
            
            to setTicket(newTicket :int) :void { ticket := newTicket }
            
            to getTicket() :int { return ticket }
            
            to rememberWhy(reason :String) :void {
                why := reason
            }
            to tellWhy() :String {
                return why
            }
        }
    }
    
    def messageGraph {
        
        to addMessageEvent(me) :void {
            dag.addVertex(me)
        }
        
        to makeMessageEvent(id :UTurn, message :Message) :near {
            return mkMessageEvent(id, message)
        }
        
        to makeMessageContext(origin :near,
                              target :near,
                              context :Tuple[SendingContext, Stack]) :near {
            return mkMessageContext(origin, target, context)
        }
        
        to optGet(id) :any { return dag.optGet(id) }
        
        to getRoots() :any { return dag.getRoots() }
        
        to getSize() :any { return dag.getSize() }
        
        to walkRelations(root, level, traceline) :void {
            def [rname, rturn] := root.getID()
            def rmsg := root.getMessage()
            traceline(`root [$rname:$rturn] $rmsg`)
            traceline(``)
            
            for edge => _ in root.outs() {
                walk(edge, level, traceline)
            }
        }
    }
    return messageGraph
}
