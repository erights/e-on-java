#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def templateNode := <elib:tables.graph.templateNode>
def templateArc := <elib:tables.graph.templateArc>

def makeDirectedGraph := <elib:tables.graph.makeDirectedGraph>

# [[start-line, start-col], [end-line, end-col]]
def SourceSpan := Tuple[Tuple[int,int], Tuple[int, int]]

# [filename, fncname]
def SourceName := Tuple[String, String]

# A [source-name, source-span]
def StackEntry := Tuple[SourceName, SourceSpan]

# top-to-bottom list of stack entries
def Stack := List[StackEntry]

def VatName := String

def Turn := int

def UTurn := Tuple[VatName, Turn]

# one of "org.ref_send.log.Sent", ...
def SendingContext := String

def Message := String

def walk(edge, level, traceline) :void {
    
    def origin := edge.getOrigin()
    def target := edge.getTarget()
    
    def who := origin.getID()
    def [oname, oturn] := who
    def omsg := origin.getMessage()
    
    def toWhom := target.getID()
    def [tname, tturn] := toWhom
    def tmsg := target.getMessage()
    
    traceline(`origin [ $oname, $oturn ] $omsg`)
    traceline(`target [ $tname, $tturn ] $tmsg`)
    traceline(``)
    
    for grandEdge => _ in target.outs() {
        walk(grandEdge, level + 1, traceline)
    }
}

/**
 * <tt>makeMessageGraph</tt>
 * <p>
 *
 */
def makeMessageGraph(traceline) :near {
    
    def dag := makeDirectedGraph(traceline)
    
    def mkTurnNode(id :UTurn, var message :Message) :near {
        var leafStack :Stack := []
        def turnNode extends templateNode(turnNode, id) {
            to getMessage() :Message { message }
            to setMessage(newMessage :Message) :void { message := newMessage }
            
            to hasLeafStack() :boolean { leafStack != [] }
            
            to getLeafStack() :Stack { leafStack }
            to setLeafStack(stack :Stack) :any { leafStack := stack }
            
            to getVatName() :VatName {
                id =~ [name, _]
                return name
            }
            
            to __printOn(out :TextWriter) :void {
                out.print(id)
            }
        }
    }
    
    def mkEventArc(origin :near,
                   target :near,
                   var context :Tuple[SendingContext, Stack]) :near {
        var anchor :int := 0
        var message :Message := ""
        def logs := [].diverge()
        var why :String := ""
        
        def eventArc extends templateArc(eventArc, origin, target) {
            to getContext() :Tuple[SendingContext, Stack] {
                return context
            }
            to setContext(ctx :Tuple[SendingContext, Stack]) :void {
                context := ctx
            }
            
            to getAnchor() :int { return anchor }
            to setAnchor(newAnchor :int) :void { anchor := newAnchor }
            
            to getMessage() :Message { message }
            to setMessage(newMessage :Message) :void { message := newMessage }
            
            to getLogFiles() :List {
                return logs.snapshot()
            }
            to addLogFile(logFile) :void {
                logs.push(logFile)
            }
            
            to rememberWhy(reason :String) :void {
                why := reason
            }
            to tellWhy() :String {
                return why
            }
        }
    }
    
    def messageGraph {
        
        to addTurnNode(node) :void {
            dag.addNode(node)
        }
        
        to makeTurnNode(id :UTurn, message :Message) :near {
            return mkTurnNode(id, message)
        }
        
        to makeEventArc(origin :near,
                        target :near,
                        context :Tuple[SendingContext, Stack]) :near {
            return mkEventArc(origin, target, context)
        }
        
        to optGet(id) :any { return dag.optGet(id) }
        
        to getRoots() :any { return dag.getRoots() }
        
        to getSize() :any { return dag.getSize() }
        
        to walkRelations(root, level, traceline) :void {
            def [rname, rturn] := root.getID()
            def rmsg := root.getMessage()
            traceline(`root [ $rname, $rturn ] $rmsg`)
            traceline(``)
            
            for edge => _ in root.outs() {
                walk(edge, level, traceline)
            }
        }
    }
    return messageGraph
}
