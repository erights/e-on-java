#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def File := <type:java.io.File>

def templateNode := <elib:tables.graph.templateNode>
def templateArc := <elib:tables.graph.templateArc>

def makeDirectedGraph := <elib:tables.graph.makeDirectedGraph>

# [[start-line, start-col], [end-line, end-col]]
def SourceSpan := Tuple[Tuple[int,int], Tuple[int, int]]

# [filename, fncname]
def SourceName := Tuple[String, String]

# A [source-name, source-span]
def StackEntry := Tuple[SourceName, nullOk[SourceSpan]]

# top-to-bottom list of stack entries
def Stack := List[StackEntry]

def VatName := String

def Turn := int

def UTurn := Tuple[VatName, Turn]

# one of "org.ref_send.log.Sent", ...
def SendingContext := String

def makeWatcher() :near {
    def items := [].asSet().diverge()
    
    def watcher {
        
        to see(item) :void {
            items.addElement(item)
        }
        
        to hasSeen(item) :boolean {
            return items.contains(item)
        }
    }
    return watcher
}

def getDisplayName(vatName) :String {
    
    if (vatName =~ `<Vat @vn>`) {
        if (vn =~ `@_/-/@name`) {
            return name
        } else {
            return vn
        }
    }
    
    # find most specific folder name
    def parts := vatName.split("/")
    var i := parts.size() -1
    while (i >= 0) {
        def part := parts[i]
        if (part != "") { return part }
        i -= 1
    }
    return vatName
}

def getHexTriple(color) :String {
    
    def rgb := [].diverge()
    
    rgb[0] := color.getRed()
    rgb[1] := color.getGreen()
    rgb[2] := color.getBlue()
    
    var result := ""
    
    for c in rgb {
        def hex := c.toString(16).toUpperCase()
        if (hex.size() == 1) {
            result += "0"
        }
        result += hex
    }
    
    return result
}

def walkDots(edge, textWriter, palette,
             vatMap, graphWalker, watcher) :void {
    
    if (watcher.hasSeen(edge)) {
        return;
    }
    watcher.see(edge)
    
    def [ovat, oturn] := edge.getOrigin().getID()
    def [tvat, tturn] := edge.getTarget().getID()
    
    def oattr := vatMap.fetchDisplayAttributes(ovat)
    def tattr := vatMap.fetchDisplayAttributes(tvat)
    
    # [vatDisplayName, [vatColor, colorName]]
    
    def oname := oattr[0]
    def tname := tattr[0]
    
    # "[buyer, 100]" -> "[product, 154]";
    
    # Should work but doesn't. Must use color names.
    #def ocolor := getHexTriple(oattr[1])
    #def tcolor := getHexTriple(tattr[1])
    #textWriter.println(`"[$oname, $oturn]" [color=#${ocolor}];`)
    #textWriter.println(`"[$tname, $tturn]" [color=#${tcolor}];`)
    
    var ocolor := oattr[1][1]
    if (edge.getOrigin().isTagged("red")) {
        ocolor := "firebrick"
    }
    var tcolor := tattr[1][1]
    if (edge.getTarget().isTagged("red")) {
        tcolor := "firebrick"
    }
    
    textWriter.println(`"[$oname, $oturn]" [color=$ocolor fontcolor=$ocolor];`)
    textWriter.println(`"[$tname, $tturn]" [color=$tcolor fontcolor=$tcolor];`)
    
    var ep := graphWalker.getElementLabel(edge)
    if (null == ep) {
        ep := "[]"
    }
    var ecolor := "black"
    if (edge.isTagged("red")) {
        ecolor := "firebrick"
    }
    textWriter.println(`"[$oname, $oturn]" -> "[$tname, $tturn]" [color=$ecolor label="$ep"];`)
    
    for grandEdge => _ in edge.getTarget().outs() {
        walkDots(grandEdge, textWriter, palette,
                 vatMap, graphWalker, watcher)
    }
}

def walk(edge, level, watcher, traceline) :void {
    
    if (watcher.hasSeen(edge)) {
        return;
    }
    watcher.see(edge)
    
    def origin := edge.getOrigin()
    def target := edge.getTarget()
    
    def who := origin.getID()
    def [oname, oturn] := who
    
    def toWhom := target.getID()
    def [tname, tturn] := toWhom
    
    def oc := `in: ${origin.getIncomingCount()}, out: ${origin.getOutgoingCount()}`
    def tc := `in: ${target.getIncomingCount()}, out: ${target.getOutgoingCount()}`
    
    var indent := ""
    for i in 0 ..! level {
        indent += "  "
    }
    def doname := getDisplayName(oname)
    def dtname := getDisplayName(tname)
    
    traceline(`$indent ($level) o: [$doname, $oturn] $oc t: [$dtname, $tturn] $tc`)
    traceline(``)
    
    for grandEdge => _ in target.outs() {
        walk(grandEdge, level + 1, watcher, traceline)
    }
}

/**
 * <tt>makeMessageGraph</tt>
 * <p>
 *
 */
def makeMessageGraph(traceline) :near {
    
    def dag := makeDirectedGraph(traceline)
    
    def mkTurnNode(id :UTurn) :near {
        var tag :String := ""
        var sendContext := ""
        var sendStack := []
        def logs := [].diverge()
        var optMessageID := null
        
        def turnNode extends templateNode(turnNode, id) {

            # A node's origin is itself.
            to getOrigin() :near {
                return turnNode
            }
            
            to getVatName() :VatName {
                return id[0]
            }
            
            to tagWith(name :String) :void {
                tag := name
            }
            to isTagged(name :String) :boolean {
                return name == tag
            }
            
            to getContext() :Tuple[SendingContext, Stack] {
                return [sendContext, sendStack]
            }
            to setSendContext(sendCtx :SendingContext, sendStk :Stack) :void {
                sendContext := sendCtx
                sendStack := sendStk
            }
            
            to getLogFiles() :List {
                return logs.snapshot()
            }
            to addLogFile(optSpan) :void {
                if (null != optSpan) {
                    logs.push(optSpan)
                }
            }
            
            to getOptText() :nullOk[String] {
                return null
            }

            to setMessageID(msg :String) :void { optMessageID := msg }
            to getMessageID() :nullOk[String] { return optMessageID }

            to __printOn(out :TextWriter) :void {
                out.print(id)
            }
        }
    }
    
    def mkEventArc(origin :near,
                   target :near,
                   var sendContext :SendingContext,
                   var sendStack :Stack) :near {
        var anchor :int := 0
        def logs := [].diverge()
        var why :String := ""
        var tag :String := ""
        var optText := null
        var optMessageID := null
        
        def eventArc extends templateArc(eventArc, origin, target) {
            to getContext() :Tuple[SendingContext, Stack] {
                return [sendContext, sendStack]
            }
            to setSendContext(sendCtx :SendingContext, sendStk :Stack) :void {
                sendContext := sendCtx
                sendStack := sendStk
            }
            
            to getAnchor() :int { return anchor }
            to setAnchor(newAnchor :int) :void { anchor := newAnchor }
            
            to getKey() :Tuple[UTurn, int] {
                return [eventArc.getOrigin().getID(), anchor]
            }
            
            to getLogFiles() :List {
                return logs.snapshot()
            }
            to addLogFile(optSpan) :void {
                if (null != optSpan) {
                    logs.push(optSpan)
                }
            }
            
            to tagWith(name :String) :void {
                tag := name
            }
            to isTagged(name :String) :boolean {
                return name == tag
            }
            
            to rememberWhy(reason :String) :void {
                why := reason
            }
            to tellWhy() :String {
                return why
            }
            
            to setOptText(text :String) :void {
                optText := text
            }
            to getOptText() :nullOk[String] {
                return optText
            }

            to setMessageID(msg :String) :void { optMessageID := msg }
            to getMessageID() :nullOk[String] { return optMessageID }
        }
    }
    
    def messageGraph {
        
        to addTurnNode(node) :void {
            dag.addNode(node)
        }
        
        to removeTurnNode(node) :void {
            dag.removeNode(node)
        }
        
        to makeTurnNode(id :UTurn) :near {
            return mkTurnNode(id)
        }
        
        to makeEventArc(origin :near,
                        target :near,
                        sendContext :SendingContext,
                        sendStack :Stack) :near {
            return mkEventArc(origin, target,
                              sendContext, sendStack)
        }
        
        to optGet(id) :near { return dag.optGet(id) }
        
        to getRoots() :near { return dag.getRoots() }
        to getLeaves() :near { return dag.getLeaves() }
        
        to getSize() :near { return dag.getSize() }
        
        to connectTheDots(root, dotFile :File, palette,
                          vatMap, graphWalker) :void {
            def textWriter := dotFile.textWriter()
            try {
                textWriter.println(`digraph messageGraph {`)
                #textWriter.println(`node [fontname=Helvetica, fontsize=10];`)
                
                def watcher := makeWatcher()
                for edge => _ in root.outs() {
                    walkDots(edge, textWriter, palette,
                             vatMap, graphWalker, watcher)
                }
                
                textWriter.println(`}`)
                textWriter.println(``)
            } finally {
                textWriter.close()
            }
        }
        
        to walkRelations(root, level, traceline) :void {
            def [vatName, turn] := root.getID()
            traceline(`root [${getDisplayName(vatName)}, $turn]`)
            traceline(``)
            def watcher := makeWatcher()
            for edge => _ in root.outs() {
                walk(edge, level +1, watcher, traceline)
            }
        }
    }
    return messageGraph
}
