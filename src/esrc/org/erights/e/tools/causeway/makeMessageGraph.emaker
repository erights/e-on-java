#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def File := <type:java.io.File>

def templateNode := <elib:tables.graph.templateNode>
def templateArc := <elib:tables.graph.templateArc>

def makeDirectedGraph := <elib:tables.graph.makeDirectedGraph>

# [[start-line, start-col], [end-line, end-col]]
def SourceSpan := Tuple[Tuple[int,int], Tuple[int, int]]

# [filename, fncname]
def SourceName := Tuple[String, String]

# A [source-name, source-span]
def StackEntry := Tuple[SourceName, nullOk[SourceSpan]]

# top-to-bottom list of stack entries
def Stack := List[StackEntry]

def VatName := String

def Turn := int

def UTurn := Tuple[VatName, Turn]

# one of "org.ref_send.log.Sent", ...
def SendingContext := String

def makeWatcher() :near {
    def items := [].asSet().diverge()
    
    def watcher {
        
        to see(item) :void {
            items.addElement(item)
        }
        
        to hasSeen(item) :boolean {
            return items.contains(item)
        }
    }
    return watcher
}


def getDisplayName(vatName) :String {
    
    if (vatName =~ `<Vat @vn>`) {
        if (vn =~ `@_/-/@name`) {
            return name
        } else {
            return vn
        }
    }
    
    # find most specific folder name
    def parts := vatName.split("/")
    var i := parts.size() -1
    while (i >= 0) {
        def part := parts[i]
        if (part != "") { return part }
        i -= 1
    }
    return vatName
}

def walkDots(edge, watcher, textWriter) :void {
    
    if (watcher.hasSeen(edge)) {
        return;
    }
    watcher.see(edge)
    
    def [oname, oturn] := edge.getOrigin().getID()
    def [tname, tturn] := edge.getTarget().getID()
    
    def doname := getDisplayName(oname)
    def dtname := getDisplayName(tname)
    
    # "[buyer, 100]" -> "[product, 154]";
    
    textWriter.println(`"[$doname, $oturn]" -> "[$dtname, $tturn]";`)
    
    for grandEdge => _ in edge.getTarget().outs() {
        walkDots(grandEdge, watcher, textWriter)
    }
}

def walk(edge, level, watcher, traceline) :void {
    
    if (watcher.hasSeen(edge)) {
        return;
    }
    watcher.see(edge)
    
    def origin := edge.getOrigin()
    def target := edge.getTarget()
    
    def who := origin.getID()
    def [oname, oturn] := who
    
    def toWhom := target.getID()
    def [tname, tturn] := toWhom
    
    def oc := `in: ${origin.getIncomingCount()}, out: ${origin.getOutgoingCount()}`
    def tc := `in: ${target.getIncomingCount()}, out: ${target.getOutgoingCount()}`
    
    var indent := ""
    for i in 0 ..! level {
        indent += "  "
    }
    def doname := getDisplayName(oname)
    def dtname := getDisplayName(tname)
    
    traceline(`$indent ($level) o: [$doname, $oturn] $oc t: [$dtname, $tturn] $tc`)
    traceline(``)
    
    for grandEdge => _ in target.outs() {
        walk(grandEdge, level + 1, watcher, traceline)
    }
}

/**
 * <tt>makeMessageGraph</tt>
 * <p>
 *
 */
def makeMessageGraph(traceline) :near {
    
    def dag := makeDirectedGraph(traceline)
    
    def mkTurnNode(id :UTurn) :near {
        def turnNode extends templateNode(turnNode, id) {
            
            to getVatName() :VatName {
                id =~ [name, _]
                return name
            }
            
            to __printOn(out :TextWriter) :void {
                out.print(id)
            }
        }
    }
    
    def mkEventArc(origin :near,
                   target :near,
                   var sendContext :SendingContext,
                   var sendStack :Stack,
                   var gotStack :Stack) :near {
        var anchor :int := 0
        def logs := [].diverge()
        var why :String := ""
        
        def eventArc extends templateArc(eventArc, origin, target) {
            to getContext() :Tuple[SendingContext, Stack] {
                return [sendContext, gotStack + sendStack]
            }
            to hasGotStack() :boolean {
                return gotStack.size() >= 1
            }
            to setSendContext(sendCtx :SendingContext, sendStk :Stack) :void {
                sendContext := sendCtx
                sendStack := sendStk
            }
            to setGotContext(gotStk :Stack) :void {
                gotStack := gotStk
            }
            
            to getAnchor() :int { return anchor }
            to setAnchor(newAnchor :int) :void { anchor := newAnchor }
            
            to getKey() :Tuple[UTurn, int] {
                return [eventArc.getOrigin().getID(), anchor]
            }
            
            to getLogFiles() :List {
                return logs.snapshot()
            }
            to addLogFile(optSpan) :void {
                if (null != optSpan) {
                    logs.push(optSpan)
                }
            }
            
            to rememberWhy(reason :String) :void {
                why := reason
            }
            to tellWhy() :String {
                return why
            }
        }
    }
    
    def messageGraph {
        
        to addTurnNode(node) :void {
            dag.addNode(node)
        }
        
        to makeTurnNode(id :UTurn) :near {
            return mkTurnNode(id)
        }
        
        to makeEventArc(origin :near,
                        target :near,
                        sendContext :SendingContext,
                        sendStack :Stack,
                        gotStack :Stack) :near {
            return mkEventArc(origin, target,
                              sendContext, sendStack, gotStack)
        }
        
        to optGet(id) :any { return dag.optGet(id) }
        
        to getRoots() :any { return dag.getRoots() }
        
        to getSize() :any { return dag.getSize() }
        
        to connectTheDots(root, dotFile :File) :void {
            def textWriter := dotFile.textWriter()
            try {
                textWriter.println(`digraph messageGraph {`)
                def watcher := makeWatcher()
                for edge => _ in root.outs() {
                    walkDots(edge, watcher, textWriter)
                }
                textWriter.println(`}`)
                textWriter.println(``)
            } finally {
                textWriter.close()
            }
        }
        
        to walkRelations(root, level, traceline) :void {
            def [vatName, turn] := root.getID()
            traceline(`root [${getDisplayName(vatName)}, $turn]`)
            traceline(``)
            def watcher := makeWatcher()
            for edge => _ in root.outs() {
                walk(edge, level +1, watcher, traceline)
            }
        }
    }
    return messageGraph
}
