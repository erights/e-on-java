#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2008 Terry Stanley under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def swt__uriGetter := <import:org.eclipse.swt.*>
def widget__uriGetter := <swt:widgets.*>
def custom__uriGetter := <swt:custom.*>
def SWT := <swt:makeSWT>

def <swttools> := <import:org.erights.e.ui.swt.*>
def swtGrid__quasiParser := <swttools:swtGridQParserMaker>()

# Useful maps for lookups in event handling.
def itemToModelMap := [].asMap().diverge()
def modelToItemMap := [].asMap().diverge()

def getNestedEdges(origin, edges, offset) :List {
    def nested := [].diverge()
    
    for i in offset ..! edges.size() {
        def edge := edges[i]
        if (edge != null) {
            if (edge.getOrigin() == origin) {
                nested.push(edge)
            } else {
                return nested.snapshot()
            }
        }
    }
    return nested.snapshot()
}

def labelNodeItem(vatMap, node, item) :void {
    def [vatName, turn] := node.getID()
    
    # Set descriptive text to vat name and turn.
    def attr := vatMap.fetchDisplayAttributes(vatName)
    item.setForeground(attr[1])
    item.setText(`[${attr[0]}, $turn]`)
}

def getEdgePart(edge) :String {
    def [sc, _] := edge.getContext()
    # find most specific sending context event type
    if (sc != "") {
        def parts := sc.split(".")
        if (parts.size() >= 1) {
            def part := parts.last()
            switch (part) {
                match `Sent` { return " ->" }
                match `SentIf` { return " ..." }
                match `Comment` { return "" }
                match _ { return ` ($part)` }
            }
        }
    }
    return ":"
}

def labelArcItem(vatMap, edge, item) :void {
    def [tVatName, tTurn] := edge.getTarget().getID()
    
    # Set descriptive text to vat name and turn.
    def tAttr := vatMap.fetchDisplayAttributes(tVatName)
    item.setForeground(tAttr[1])
    def part := getEdgePart(edge)
    def msg := edge.getMessage()
    if (tAttr[0] == "ether") {
        item.setText(`$msg$part`)
    } else {
        item.setText(`$msg$part [${tAttr[0]}, $tTurn]`)
    }
}

def buildTreeItems(parent, palette, vatMap, origin, edges, ndx) : void {
    
    # Make tree item for origin.
    def item := <widget:makeTreeItem>(parent, 0)
    labelNodeItem(vatMap, origin, item)
    
    for i in 0 ..! edges.size() {
        
        def edge := edges[i]
        
        # Make nested tree item for edge.
        def nested := <widget:makeTreeItem>(item, 0)
        
        itemToModelMap.put([nested, ndx], edge, true)
        modelToItemMap.put(edge, [nested, ndx], true)
        
        labelArcItem(vatMap, edge, nested)
    }
}

def buildTree(parent, palette, vatMap, poList, ndx) :void {
    
    var i := 0
    while (i < poList.size()) {
        
        def edge := poList[i]
        if (edge != null) {
            def origin := edge.getOrigin()
            # edges will contain at least one edge
            def edges := getNestedEdges(origin, poList, i)
            buildTreeItems(parent, palette, vatMap, origin, edges, ndx)
            
            i += edges.size()
            
        } else {
            i := i +1
        }
    }
}

def makePOPane(parent, palette, vatMap, poList, ndx, selectionModel) :near {
    
    def pane := <widget:makeComposite>(parent, 0)
    def tree := <widget:makeTree>(pane,
                                  SWT.getSINGLE() |
                                    (SWT.getH_SCROLL() | SWT.getV_SCROLL()))
    
    def popp := palette.makePOPanePalette()
    pane.setForeground(popp.getFg())
    pane.setBackground(popp.getBg())
    pane.setFont(popp.getFont())
    tree.setForeground(popp.getFg())
    tree.setBackground(popp.getBg())
    tree.setFont(popp.getFont())
    
    buildTree(tree, palette, vatMap, poList, ndx)
    
    def selectionListener {
        to widgetSelected(event) :void {
            def item := event.getItem()
            def edge := itemToModelMap.fetch([item, ndx], fn{})
            selectionModel.setOptEdge(edge)
        }
        to widgetDefaultSelected(event) :void {}
    }
    tree.addSelectionListener(selectionListener)
    
    def pop {
        
        to getPane() :near { return pane }
        
        to getWidget() :near { return tree }
        
        to activate() :void {}
        
        to layout() :void {
            
            swtGrid`${pane}:
                        ${tree}.X.Y`
            
            pane.getLayout().setMarginWidth(0)
            pane.getLayout().setMarginHeight(0)
            pane.getLayout().setHorizontalSpacing(0)
            pane.getLayout().setVerticalSpacing(0)
        }
    }
    return pop
}

def makePOGroup(folder, palette, vatMap, model, selectionModel) :near {
    
    def tabKeeper := [].diverge()
    
    # Map [VatName, List[EventArc]]
    for vatName => poList in model {
        
        def tab := <widget:makeTabItem>(folder, 0)
        
        def pop := makePOPane(folder, palette, vatMap,
                              poList, folder.indexOf(tab), selectionModel)
        
        tab.setControl(pop.getPane())
        tab.setText(vatMap.fetchDisplayAttributes(vatName)[0])
        tabKeeper[folder.indexOf(tab)] := [tab, pop]
    }
    
    def selectionObserver {
        to edgeSelected(optEdge) :void {
            def tabbedItem := modelToItemMap.fetch(optEdge, fn{})
            if (tabbedItem != null) {
                def [item, ndx] := tabbedItem
                folder.setSelection(ndx)
                def [_, pop] := tabKeeper[ndx]
                pop.getWidget().setSelection([item])
                pop.getWidget().showItem(item)
            }
        }
    }
    selectionModel.addObserver(selectionObserver)
    
    
    def pog {
        to layout() :void {
            for [_, pop] in tabKeeper {
                pop.layout()
            }
        }
        
        to open() :void {}
    }
    return pog
}
