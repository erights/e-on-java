#!/usr/bin/env rune

# Copyright 2006 Hewlett Packard, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")

def map(func, list) {
    var result := []
    for element in list {
        result with= func(element)
    }
    return result
}

def makeDeliverator(myServPolicy,
                    myUnsealer,
                    myTarget,
                    responsible :dist[Who]) {
    def deliverator {
        to deliver(box) {
            switch (myUnsealer(box)) {

                match [`request`,
                       verb :String,
                       sealedArgs :List[Opaque],
                       resolver :dist[Resolver]] {

                    def args := map(myUnsealer, sealedArgs)
                    # XXX Oops. I need some way to recognize
                    # when the arg is a dist[Deliverator] that I
                    # need to wrap in a Proxy before I can
                    # deliver it. Or when it is one of my own
                    # Deliverators that I need to unwrap before
                    # delivery.
                    def result := myServPolicy.call(responsible,
                                                    myTarget,
                                                    verb,
                                                    args)
                    resolver <- resolve(result)
                }

                match [`intro`,
                       why :String,
                       other :dist[Who],
                       resolver :dist[Resolver]] {

                    myServPolicy.intro(responsible,
                                       why, other, myTarget)
                    def newD := makeDeliverator(myServPolicy,
                                                myUnsealer,
                                                myTarget,
                                                other)
                    # This is the crucial step that cuts responsible
                    # out of the middle if other should ever
                    # prove to be independent.
                    def result := other <- sealArg(newD)
                    resolver <- resolve(result)
                }
            }
        }
    }
    return deliverator
}
